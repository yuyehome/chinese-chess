### **详细设计文档: A-3.1模块化游戏模式管理器 **

**文档版本**: 1.0  
**设计目标**:

1. **(A-3.1)** 构建一个可插拔的游戏模式管理系统，能够根据选择的模式（回合制、实时制等）加载并执行对应的游戏规则。
    
2. **(A-4.1)** 建立一个严格的视图-逻辑分离框架，确保游戏表现层(View)仅作为GameState的“渲染器”，而用户输入则作为ICommand的“生产者”。
    

---

### **模块 1: Core.GameModes - 模块化游戏模式管理器**

#### **1.1. 模块目标 (Goal)**

将游戏规则从核心循环中解耦。使得添加一个全新的游戏模式（例如未来可能出现的“解谜模式”）只需要编写一个新的规则逻辑类，而无需改动CommandProcessor或GameLoopController等核心代码。

#### **1.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/_Core/GameModes/
    
- **接口设计**:
    
    1. **IGameModeLogic**
        
        - **类型**: 接口
            
        - **职责**: 定义所有游戏模式规则集必须遵守的契约。
            
        - **详细功能说明**: CommandProcessor将持有该接口的一个实例。在处理指令或更新游戏状态时，CommandProcessor会将具体工作委托给这个接口的实现类。
            
        - **关键方法**:
            
            - void Initialize(GameState state, GameSetupData setupData);: 在对局开始时调用，用于根据初始配置设置GameState的初始状态（例如，创建所有初始棋子）。
                
            - bool ValidateCommand(ICommand command, GameState state);: **核心验证方法**。在指令执行前，检查该指令在当前游戏规则和状态下是否合法。例如，实时模式下检查行动点，回合制下检查是否轮到该玩家。
                
            - void OnTick(GameState state);: **核心更新方法**。在每个固定的逻辑tick（例如每秒30次）被调用，用于处理随时间变化的状态更新，如行动点恢复、技能CD减少等。仅对实时模式有意义。
                
- **管理器设计**:
    
    1. **GameModeManager**
        
        - **类型**: 普通 C# 工厂类
            
        - **职责**: 根据游戏模式类型，创建对应的IGameModeLogic实例。
            
        - **详细功能说明**: 这是一个简单的工厂，用于解耦GameLoopController和具体的规则类。
            
        - **关键方法**:
            
            - public static IGameModeLogic CreateLogic(GameModeType modeType);: 传入一个枚举（如GameModeType.RealTime_Fair），返回一个new RealTimeLogic()实例。
                

---

### **详细设计文档: A-4.1视图与逻辑分离框架**

#### **2.1. 模块目标 (Goal)**

建立清晰的数据流管道：  
输入 (InputController) -> 指令 (ICommand) -> 逻辑处理 (CommandProcessor) -> 状态 (GameState) -> 表现 (View)。  
确保View层永远不直接修改GameState，也永远不包含游戏规则逻辑。

#### **2.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/_Core/Controller/, Assets/_Core/View/
    
- **控制器类设计 (Controller)**:
    
    1. **GameLoopController**
        
        - **类型**: MonoBehaviour 单例
            
        - **职责**: 游戏主循环的驱动器和所有核心系统的“粘合剂”。
            
        - **详细功能说明**: 负责在对战场景中初始化、驱动和销毁核心游戏系统。
            
        - **关键方法**:
            
            - void Awake(): 初始化CommandProcessor, GameState, InputController, GameModeManager等。
                
            - void Start(): 调用IGameModeLogic.Initialize()来设置棋局初始状态，并通知BoardView生成棋子。
                
            - void FixedUpdate(): **游戏逻辑的心跳**。以固定的时间间隔（Time.fixedDeltaTime）调用CommandProcessor.Tick()，从而驱动IGameModeLogic.OnTick()。
                
            - void Update(): 处理与逻辑无关的更新，例如视图层的插值计算，确保画面在不同帧率下都平滑。
                
    2. **InputController**
        
        - **类型**: MonoBehaviour
            
        - **职责**: 捕获原始用户输入（鼠标点击、按键），并将其翻译成游戏意图（ICommand）。
            
        - **详细功能说明**: 它维护一个简单的状态机来处理多步操作，如“选中棋子”->“选择目标点”。
            
        - **关键成员**:
            
            - private PieceData selectedPiece;: 当前选中的棋子。
                
            - void Update(): 监听鼠标点击。如果点击到棋子，则选中；如果已选中棋子，再点击合法位置，则创建一个MoveCommand并发送。
                
            - void SendCommand(ICommand command): 将创建的指令发送给INetworkService。
                
- **视图类设计 (View)**:
    
    1. **BoardView**
        
        - **类型**: MonoBehaviour
            
        - **职责**: GameState中棋子列表在场景中的总代理。负责根据GameState创建、销毁和管理所有的PieceView GameObject。
            
        - **详细功能说明**: 它订阅了CommandProcessor.OnGameStateUpdated事件。
            
        - **关键方法**:
            
            - void OnGameStateUpdated(GameState newState): 收到新的状态后，与当前场景中的棋子进行比对。如果newState.pieces中多了一个棋子，就实例化一个新的PieceView；如果少了一个，就播放死亡动画并销毁对应的PieceView。
                
    2. **PieceView**
        
        - **类型**: MonoBehaviour
            
        - **职责**: **单个棋子在场景中的视觉表现**。
            
        - **详细功能说明**: 每个PieceView都与GameState中的一个PieceData通过uniqueId关联。它不存储游戏逻辑状态，只存储表现层状态（如动画目标位置）。
            
        - **关键成员**:
            
            - public int pieceId;: 关联的PieceData.uniqueId。
                
            - private Vector3 targetPosition;: 移动动画的目标世界坐标。
                
            - void OnGameStateUpdated(GameState newState): 监听到状态更新后，找到newState.pieces[pieceId]，检查自己的数据是否有变化。
                
            - **插值逻辑**: 如果发现PieceData.position变了，它不会瞬间移动过去，而是更新targetPosition。在Update()方法中，使用Vector3.Lerp或Vector3.MoveTowards平滑地将自己的transform.position移动到targetPosition，从而创建移动动画。
                
            - void PlayEffect(string effectName): 用于播放受击、死亡、技能等特效。
                

#### **2.3. Unity工作流 (Unity Workflow)**

1. **场景搭建 (BattleScene)**:
    
    - 创建一个名为GameSystems的空GameObject。
        
    - 将GameLoopController, InputController, BoardView, AudioManager, LocalizationManager等核心管理器的脚本挂载到GameSystems或其子对象上。
        
    - 创建一个棋盘模型。
        
2. **Prefab制作**:
    
    - 为每种棋子创建一个Prefab。Prefab的根节点上挂载PieceView.cs脚本。子节点包含模型、碰撞体、特效挂点等。
        
3. **开发流程**:
    
    - **添加新规则**: 假设我们要为实时模式添加“棋子中毒”状态。开发者只需：
        
        1. 在PieceState枚举中添加Poisoned。
            
        2. 在IGameModeLogic的OnTick方法中，检查中毒的棋子并扣血（修改PieceData的生命值属性）。
            
        3. 在PieceView的OnGameStateUpdated中，检查到状态变为Poisoned时，播放一个中毒的粒子特效。
            
    - 整个过程中，GameLoopController, CommandProcessor等核心代码完全不需要改动。
        

---