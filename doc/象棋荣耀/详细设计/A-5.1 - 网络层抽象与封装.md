### **详细设计文档: A-5.1 - 网络层抽象与封装**

**文档版本**: 1.0  
**设计目标**: 构建一个高度抽象的网络层。上层游戏逻辑（如InputController）不应直接与Fish-Networking的具体API耦合，而是通过一个统一的接口(INetworkService)进行通信。这使得底层网络库的更换、单机/联机模式的切换都变得轻而易举，并且极大地提升了代码的可测试性。

---

### **模块: Core.Networking - 网络服务**

#### **1.1. 模块目标 (Goal)**

封装所有网络通信的复杂性，为上层逻辑提供简单、统一的接口来发送指令、接收状态更新以及管理网络会话（创建/加入房间）。

#### **1.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/_Core/Networking/
    
- **接口设计 (The Contract)**:
    
    1. **INetworkService**
        
        - **类型**: 接口
            
        - **职责**: **定义网络层对外提供服务的所有功能的契约**。这是整个网络抽象的核心。
            
        - **详细功能说明**: 游戏的其他部分（如InputController, GameLoopController, LobbyUI）将只持有这个接口的引用，而不知道底层到底是FishNet在工作还是一个模拟的离线服务。
            
        - **关键事件**:
            
            - event Action OnConnected;: 当成功连接到服务器/启动主机时触发。
                
            - event Action OnDisconnected;: 当连接断开时触发。
                
            - event Action<GameState> OnGameStateUpdated;: **核心事件**。当接收到服务器权威的GameState快照时触发。
                
            - event Action<LobbyState> OnLobbyStateUpdated;: 当大厅/房间信息更新时触发。
                
        - **关键方法**:
            
            - bool IsHost { get; }: 判断当前客户端是否是主机(Host/Server)。
                
            - void StartHost(GameSetupData setup);: 以主机模式启动游戏。
                
            - void StartClient(string address);: 以客户端模式连接到指定地址。
                
            - void Disconnect();: 断开连接。
                
            - void SendCommand(ICommand command);: **核心方法**。向服务器发送一个指令。
                
            - void CreateLobby(LobbySettings settings);: 创建一个大厅/房间。
                
            - void JoinLobby(string lobbyId);: 加入一个大厅/房间。
                
            - void UpdatePlayerReadyState(bool isReady);: 更新玩家在房间中的准备状态。
                
- **实现类 1: 在线模式 (The Real Deal)**:
    
    1. **FishNetService**
        
        - **类型**: class FishNetService : MonoBehaviour, INetworkService (需要是MonoBehaviour以接收FishNet回调)
            
        - **职责**: 实现INetworkService接口，内部调用Fish-Networking的API来完成所有网络功能。
            
        - **详细功能说明**: 这是真正的网络功能实现者。它会管理FishNet的NetworkManager，处理连接、收发包、序列化等所有底层细节。
            
        - **内部逻辑**:
            
            - 在StartHost中，调用NetworkManager.ServerManager.StartConnection() 和 NetworkManager.ClientManager.StartConnection()。
                
            - 在SendCommand中，构造一个RPC（远程过程调用），将序列化后的ICommand发送给服务器。
                
                - [ServerRpc] public void RpcSendCommand(ICommand command, NetworkConnection sender = null)
                    
            - 服务器端接收到RPC后，将指令交给CommandProcessor处理。
                
            - 服务器的GameLoopController在每个tick或状态变化后，获取最新的GameState，并通过一个[ObserversRpc]将GameState广播给所有客户端。
                
            - 客户端的FishNetService接收到这个RPC，然后触发OnGameStateUpdated事件，将新的状态传递给上层逻辑。
                
            - 连接和断开的回调函数会触发OnConnected和OnDisconnected事件。
                
- **实现类 2: 单机/离线模式 (The Fake)**:
    
    1. **OfflineService**
        
        - **类型**: class OfflineService : INetworkService (无需是MonoBehaviour)
            
        - **职责**: 同样实现INetworkService接口，但在内部**模拟一个网络环境**，用于单机游戏。
            
        - **详细功能说明**: 它的存在使得单机模式和联机模式可以使用**完全相同**的游戏逻辑代码，无需写任何if (isOnline)之类的判断。
            
        - **内部逻辑**:
            
            - 持有一个本地的GameLoopController和CommandProcessor的引用。
                
            - IsHost 始终返回 true。
                
            - StartHost方法会立即创建一个本地的GameLoopController，并触发OnConnected事件。
                
            - SendCommand方法**不通过网络发送**，而是直接将command对象传递给本地的CommandProcessor.ProcessCommand(command)。
                
            - 它会订阅本地CommandProcessor的OnGameStateUpdated事件，当事件触发时，它再触发自己的OnGameStateUpdated事件，完美模拟了从“服务器”接收到状态更新的过程。
                
            - Disconnect方法会清理本地游戏循环并触发OnDisconnected。
                
- **服务定位器/依赖注入 (The Manager)**:
    
    1. **NetworkServiceProvider**
        
        - **类型**: 静态类或单例
            
        - **职责**: 作为INetworkService的统一访问点。根据游戏启动模式，决定提供FishNetService还是OfflineService的实例。
            
        - **详细功能说明**: 游戏中的任何代码需要网络服务时，都向NetworkServiceProvider.Instance请求，而不是直接去查找FishNetService。
            
        - **关键成员**:
            
            - public static INetworkService Instance { get; private set; }
                
            - public static void Initialize(bool isOnline): 在游戏启动的最开始（例如主菜单场景）被调用。
                
                - 如果isOnline为true，则在场景中找到（或创建）一个FishNetService实例并赋值给Instance。
                    
                - 如果isOnline为false，则new OfflineService()并赋值给Instance。
                    

#### **1.3. Unity工作流 (Unity Workflow)**

1. **场景设置**:
    
    - 在InitScene或MainMenuScene中，创建一个名为NetworkManager的GameObject。
        
    - 挂载Fish-Networking的NetworkManager组件。
        
    - **同时**挂载我们自己编写的FishNetService.cs脚本。这个脚本会在内部获取NetworkManager的引用。
        
2. **启动流程 (以玩家点击主菜单按钮为例)**:
    
    - **点击“单人游戏”按钮**:
        
        1. UI脚本调用 NetworkServiceProvider.Initialize(isOnline: false);
            
        2. UI脚本调用 NetworkServiceProvider.Instance.StartHost(gameSetupData);
            
        3. OfflineService被激活，创建本地游戏循环，加载战斗场景。
            
    - **点击“创建房间”按钮**:
        
        1. UI脚本调用 NetworkServiceProvider.Initialize(isOnline: true);
            
        2. UI脚本调用 NetworkServiceProvider.Instance.StartHost(gameSetupData);
            
        3. FishNetService被激活，启动FishNet的Host模式，加载战斗场景。
            
3. **游戏逻辑中的使用 (示例)**:
    
    - InputController中需要发送移动指令的地方，代码永远是：
        
        codeC#
        
        ```
        MoveCommand cmd = new MoveCommand(pieceId, targetPos);
        NetworkServiceProvider.Instance.SendCommand(cmd);
        ```
        
        这段代码完全不知道底层是网络发送还是本地调用，实现了完美的解耦。
        
4. **FishNet配置**:
    
    - 所有需要网络同步的struct或class（如GameState, PieceData, 所有ICommand实现类）都需要被FishNet的代码生成器处理。通常只需在类上添加相应的标记（FishNet使用[NetworkBehaviour]等，但对于INetworkSerializable，主要是确保有序列化和反序列化方法）。
        

---