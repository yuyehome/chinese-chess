
### **详细设计文档: B-3.1 - 技能系统框架 (M3)**

**文档版本**: 1.0  
**设计目标**: 构建一个高度模块化、数据驱动、易于扩展的技能系统。该系统能够支撑当前设计草稿中的绝大部分技能类型，并为未来更复杂的技能提供坚实的基础。

---

### **第一部分：核心功能与逻辑说明 (Functional & Logic Specification)**

本技能系统基于“**触发器(Trigger) + 目标器(Targeter) + 效果(Effect)**”三位一体的设计模式。

1. **触发器 (Trigger)**: 定义了技能**何时**被激活。
    
    - **主动触发**: 玩家点击技能按钮，发送UseSkillCommand。
        
    - **被动触发**: 游戏中的特定事件发生时自动触发，例如：
        
        - OnMoveEnd (移动结束时，用于“战争践踏”等)
        - OnMoving（移动过程中，用于“火焰战车”）
        - OnPieceDie (棋子死亡时，用于“郭嘉遗计”、“死亡陷阱”)
        - OnKill (成功击杀敌人时，用于“白起吸血”)
            
2. **目标器 (Targeter)**: 定义了技能对**谁**生效。
    
    - 技能被触发后，目标器会根据预设的规则（如范围、敌我、棋子类型）从当前的GameState中找出一个或多个目标棋子ID列表。
        
    - **示例**:
        
        - SelfTargeter: 目标是施法者自己。
            
        - AreaTargeter: 目标是施法者周围N格范围内的所有棋子。
            
        - EnemyInLineTargeter: 目标是施法者前方直线上的第一个敌方单位。
            
3. **效果 (Effect)**: 定义了技能**做什么**。
    
    - 这是技能的核心。一个技能可以包含多个效果。效果是原子化的操作。
        
    - **示例**:
        
        - StunEffect: 修改目标棋子的PieceStatus，添加Stunned标志。
            
        - DamageEffect: 对目标造成伤害（在我们的游戏中表现为直接击杀）。
            
        - SpawnPieceEffect: 在指定位置创建一个新的PieceData并加入GameState。
            
        - ApplyStatusEffect: 为目标施加一个持续性的状态（如隐身、无敌）。
            

**示例技能解析：“战争践踏”**

- **Trigger**: OnMoveEnd (被动)
    
- **Targeter**: AreaTargeter (范围: 周围8格, 目标: 所有棋子, 包括自己和友军)
    
- **Effects**:
    
    1. StunEffect (持续时间: 3秒)
        

---

### **第二部分：技术架构与代码设计 (Technical & Code Design)**

### **模块 1: Core.Data & Core.GameState (扩展)**

- **代码路径**: Assets/_Core/Data/, Assets/_Core/GameState/
    
- **PieceData 扩展**:
    
    - public List<int> activeEffectIds;: 存储当前作用在该棋子上的持续性效果的ID。
        
- **GameState 扩展**:
    
    - public Dictionary<int, ActiveEffectData> activeEffects;: **核心数据**。全局的持续性效果列表，Key是效果的唯一ID。
        
- **ActiveEffectData 结构体**:
    
    - public int effectId;
        
    - public int sourcePieceId; (效果来源)
        
    - public int targetPieceId; (效果目标)
        
    - public float remainingDuration; (剩余持续时间)
        

### **模块 2: Gameplay.Skills - 技能系统核心**

- **代码路径**: Assets/_Gameplay/Skills/
    

#### **2.1. ScriptableObject 配置 (数据驱动)**

- **路径**: Assets/_Content/Skills/
    
- **核心设计**: 我们将技能、目标器、效果全部设计成ScriptableObject，让策划可以通过Unity Inspector来“组装”技能，而无需编写代码。
    

1. **SkillConfig.cs** (之前已定义，现在扩展)
    
    - public TriggerConfig trigger; (触发器配置)
        
    - public TargeterConfig targeter; (目标器配置)
        
    - public List<EffectConfig> effects; (效果配置列表)
        
2. **TriggerConfig** (抽象基类 ScriptableObject)
    
    - **子类**: ActiveTriggerConfig, PassiveTriggerConfig
        
    - PassiveTriggerConfig 字段: public GameEvent triggerEvent; (GameEvent是一个枚举, 如OnMoveEnd)
        
3. **TargeterConfig** (抽象基类 ScriptableObject)
    
    - **核心方法**: public abstract List<int> FindTargets(GameState state, int casterId, Vector2Int targetPos);
        
    - **子类**: SelfTargeterConfig, AreaTargeterConfig (字段: float radius), SingleTargeterConfig
        
4. **EffectConfig** (抽象基类 ScriptableObject)
    
    - **核心方法**: public abstract ICommand CreateEffectCommand(int casterId, List<int> targetIds);
        
    - **子类**: StunEffectConfig (字段: float duration), SpawnEffectConfig (字段: PieceType pieceToSpawn), ApplyStatusEffectConfig (字段: PieceStatus status, float duration)
        

#### **2.2. 逻辑执行器**

1. **SkillSystem**
    
    - **类型**: static class
        
    - **职责**: 技能系统的中心枢纽，处理技能的触发和执行。
        
    - **关键方法**:
        
        - **ProcessActiveSkill(GameState state, UseSkillCommand cmd)**:
            
            1. 获取技能配置 skillConfig。
                
            2. 调用 skillConfig.targeter.FindTargets() 获取目标列表。
                
            3. 遍历 skillConfig.effects，为每个效果创建对应的ICommand。
                
            4. 返回一个包含所有效果指令的列表，由CommandProcessor执行。
                
        - **ProcessPassiveEvent(GameState state, GameEvent gameEvent, int pieceId)**:
            
            1. 检查 pieceId 对应的棋子是否拥有与 gameEvent 匹配的被动技能。
                
            2. 如果匹配，则执行与主动技能类似的目标查找和效果创建流程。
                
2. **RealTimeSkillLogic** (M3模式逻辑)
    
    - **类型**: class RealTimeSkillLogic : RealTimeLogic (继承自M2的逻辑)
        
    - **职责**: 在M2的基础上，增加对技能指令和事件的处理。
        
    - **ValidateCommand 扩展**: 增加对UseSkillCommand的验证（CD是否冷却、行动点/魔法值是否足够）。
        
    - **OnTick 扩展**:
        
        1. 调用基类RealTimeLogic.OnTick。
            
        2. **遍历 state.activeEffects**:
            
            - 减少所有效果的remainingDuration。
                
            - 移除已到期的效果，并生成一个“效果结束”的内部指令（如 RemoveStatusCommand）来更新对应棋子的PieceStatus。
                
3. **新的指令 (ICommand)**
    
    - ApplyStatusCommand(targetId, status, duration): 添加一个持续性效果到GameState。
        
    - SpawnPieceCommand(team, type, position): 创建一个新棋子。
        
    - TeleportPieceCommand(targetId, position): 改变棋子位置。
        

#### **2.3. Unity工作流**

1. **创建技能**:
    
    - 策划在Project窗口右键 -> Create -> ChessHonor -> Skills
        
    - **创建效果**: 创建一个StunEffectConfig实例，设置duration = 3.0f。
        
    - **创建目标器**: 创建一个AreaTargeterConfig实例，设置radius = 2.0f (2格范围)。
        
    - **创建触发器**: 创建一个PassiveTriggerConfig实例，选择triggerEvent = OnMoveEnd。
        
    - **组装技能**: 创建一个SkillConfig实例，命名为SK_WarStomp。将上面创建的三个配置拖拽到对应的字段中。
        
2. **绑定技能**:
    
    - 打开“战争践踏象”的HeroConfig，将SK_WarStomp这个SkillConfig拖拽到其技能字段上。
        
3. **游戏运行**:
    
    - 游戏开始时，SkillSystem会加载所有英雄的被动技能，并注册到事件监听器中。
        
    - 当一个带有“战争践踏”技能的象移动结束时，GameLoopController会发布一个OnMoveEnd事件。
        
    - SkillSystem捕获事件，找到对应的技能，开始执行目标查找和效果应用流程，最终生成指令并修改GameState。


- **对现有技能草稿的支持度**:
    
    - **可直接支持**: 眩晕、击退、召唤、复活、隐身、无敌、持续伤害（火墙）、各种范围效果。
        
    - **需要特殊EffectConfig支持**: “夺魂”（需要一个MorphEffect）、“劝降”（需要一个ConvertTeamEffect）、“指挥类”（如鼓舞士气，需要一个能触发其他棋子移动的MassMoveEffect）。这些都可以作为新的EffectConfig子类被平滑地添加到框架中，**无需修改核心系统**。
        
    - **复杂逻辑**: “战争迷雾/视野”系统比较特殊，它需要一个独立的FogOfWarSystem，但技能（如“致盲”）可以作为触发器，通过ApplyFogEffect来影响这个系统。