### **详细设计文档: C-3.1 & C-4.1 - 经济与持久化系统**

**文档版本**: 1.0  
**设计目标**:

1. **(C-3.1)** 构建一个分层、多货币的经济体系，支持直购和礼包等多种商业模式，并为Steam分区定价提供支持。
    
2. **(C-4.1)** 实现一个以“离线优先”为核心原则的安全数据持久化方案。该方案需保证游戏在无网络、无后端服务器的情况下功能完整，同时具备基础的防篡改能力，并为未来的在线排行榜验证预留接口。
    

---

### **第一部分：核心功能与逻辑说明 (Functional & Logic Specification)**

#### **1. 经济模型：三轨货币体系**

本游戏采用三种核心资源驱动经济循环，旨在平衡付费与免费玩家的体验，最大化商业潜力。

- **金币 (Soft Currency)**: 核心的游戏内免费货币。通过对战、任务、签到等方式大量产出。用于购买大部分基础武将和皮肤，是玩家“肝”的主要动力。
    
- **钻石 (Hard Currency)**: 核心的付费货币，**仅能通过Steam钱包充值获得**。用于购买限定/高级外观、武将，以及其他增值服务。这是游戏的主要收入来源。
    
- **武魂碎片 (Resource)**: 英雄专属资源。通过任务奖励、重复获得英雄转化、商店购买等方式获取。用于合成特定的未拥有武将，为玩家提供长期的收集目标。
    

#### **2. 商店策略与Steam集成**

- **商业模式**: 商店以**明码标价的直购**和**捆绑折扣礼包**为主要销售模式。初期版本不引入复杂的Gacha（抽卡/开箱）系统，保证付费体验的确定性。
    
- **Steam分区定价**: 所有付费商品（如钻石包）将以DLC的形式在Steam上架。我们会设置美元基准价，并**完全利用Steamworks后台提供的区域化定价建议**，以适应全球不同市场的消费能力。
    

#### **3. 数据持久化核心原则：“离线优先”与安全**

- **本地权威**: 玩家的所有核心进度数据 (PlayerProfile) **始终以加密文件形式存储在本地**。这是游戏数据的唯一真相来源，确保了游戏在任何网络环境下，甚至在开发者服务器完全关闭后，依然保有其核心玩法和成长循环的完整性。
    
- **Steam云同步**: 本地存档将通过Steam Cloud自动同步，为玩家提供跨设备游戏和数据备份的基础保障。
    
- **基础防作弊**: 采用**存档校验和 (Checksum)** 机制。每次保存数据时，都会根据数据内容和一个内部密钥生成一个哈希签名。加载时会进行验证，若数据被篡改导致签名不匹配，系统将执行回档或重置等安全策略，有效防止初级的文件修改作弊。
    
- **渐进式在线增强**: 本地存档系统将预留接口，以便在未来版本中，让希望参与官方排行榜的玩家能**自愿**将其存档提交到官方服务器进行**二次验证**。这实现了排行榜的相对公平，同时不强制所有玩家依赖于后端服务。
    

---

### **第二部分：技术架构与代码设计 (Technical & Code Design)**

### **模块 1: App.Economy - 经济系统**

- **代码路径**: Assets/_App/Economy/
    

#### **1.1. 货币与资源管理**

- **CurrencyManager**
    
    - **类型**: class (由PlayerDataManager持有和管理)
        
    - **职责**: 在内存中管理玩家当前的货币和资源数量，并提供安全的增减接口。
        
    - **详细功能说明**: 任何需要改变玩家货币的操作（如发奖励、购买商品）都必须通过这个管理器。它不直接负责存盘，而是作为PlayerProfile在内存中的一个代理。
        
    - **关键方法**:
        
        - bool HasEnough(CurrencyType type, long amount);
            
        - void Add(CurrencyType type, long amount);
            
        - bool Spend(CurrencyType type, long amount); (如果足够则扣除并返回true)
            
    - **CurrencyType**: enum { Gold, Diamond, HeroShard }
        

#### **1.2. 任务与签到系统**

- **TaskManager**
    
    - **类型**: class
        
    - **职责**: 管理所有任务（每日、每周、成就）的进度追踪、完成判断和奖励发放。
        
    - **数据结构**: TaskData (存储任务进度)，TaskConfig (ScriptableObject，配置任务目标和奖励)。
        
    - **逻辑**: 监听全局游戏事件（如OnGameWin, OnPieceKilled），更新相关任务的进度。
        
- **SignInManager**
    
    - **类型**: class
        
    - **职责**: 管理每日签到逻辑和奖励。
        

#### **1.3. 商店系统**

- **ShopManager**
    
    - **类型**: class
        
    - **职责**: 管理商店的商品逻辑，处理购买流程。
        
    - **数据结构**: ShopItemConfig (ScriptableObject，配置商品ID、名称、描述、价格、包含内容等)。
        
    - **关键方法**:
        
        - PurchaseResult PurchaseItem(string itemId);
            
            - **逻辑**:
                
                1. 获取ShopItemConfig。
                    
                2. 检查玩家CurrencyManager中的货币是否足够。
                    
                3. 调用CurrencyManager.Spend()扣款。
                    
                4. 如果成功，则调用PlayerDataManager给予玩家物品（如解锁英雄）。
                    
                5. 返回购买结果（成功、失败-金币不足等）。
                    
- **SteamStoreIntegration**
    
    - **类型**: class
        
    - **职责**: 专门处理与Steam钱包的交互。
        
    - **逻辑**: 当玩家点击购买“钻石”商品时，调用Steamworks.NET的API（如SteamMicroTxn.InitTxn）拉起Steam的支付覆盖层。监听支付成功的回调，然后在回调中安全地给予玩家CurrencyManager.Add(CurrencyType.Diamond, ...)。
        

### **模块 2: App.Persistence - 数据持久化**

- **代码路径**: Assets/_App/Persistence/
    

#### **2.1. 核心数据管理**

- **PlayerDataManager**
    
    - **类型**: 单例
        
    - **职责**: 游戏运行期间，**唯一持有和管理** PlayerProfile 内存实例的权威。所有模块需要访问或修改玩家数据，都必须通过它。
        
    - **关键成员**:
        
        - public PlayerProfile Profile { get; private set; }
            
        - public CurrencyManager Currencies { get; private set; }
            
        - public InventoryManager Inventory { get; private set; } (管理已解锁的英雄/皮肤)
            
    - **关键方法**:
        
        - void LoadPlayerData();: 游戏启动时调用，执行加载、解密、校验流程。
            
        - void SavePlayerData();: 在关键节点（如对局结束、购买成功、退出游戏）调用。
            
        - void UnlockHero(int heroId);
            

#### **2.2. 存取与加密**

- **SaveLoadSystem**
    
    - **类型**: static class
        
    - **职责**: 负责文件的读写、加密、解密和校验和计算。
        
    - **关键方法**:
        
        - private static string secretKey = "9527"; (这个密钥不能硬编码，需要用一些混淆手段保护)
            
        - public static void Save(PlayerProfile data, string filePath):
            
            1. 将data对象序列化为JSON字符串。
                
            2. **计算校验和**: checksum = SHA256(json_string + secretKey)。
                
            3. 创建一个包含{ "data": json_string, "checksum": checksum }的新JSON结构。
                
            4. **加密**: 对这个新JSON结构进行加密（如AES加密）。
                
            5. 将加密后的二进制数据写入文件。
                
        - public static PlayerProfile Load(string filePath):
            
            1. 读取文件的二进制数据。
                
            2. **解密**。
                
            3. 解析出data和checksum。
                
            4. **验证**: 重新计算 expected_checksum = SHA256(data + secretKey)。
                
            5. **如果 checksum != expected_checksum，则存档被篡改，加载失败，返回null。**
                
            6. 如果验证通过，将data反序列化为PlayerProfile对象并返回。
                

---

### **Unity工作流 (Unity Workflow)**

1. **配置商品**:
    
    - 策划在Assets/_Content/Shop/目录下，创建ShopItemConfig ScriptableObject。例如，创建一个Hero_GuanYu.asset，在Inspector中设置其价格为{ currencyType: Gold, amount: 5000 }。
        
2. **启动流程**:
    
    - 游戏启动时，一个GameInitializer脚本会调用PlayerDataManager.Instance.LoadPlayerData()。
        
    - 如果加载失败（文件损坏或篡改），则为玩家创建一个新的PlayerProfile。
        
3. **游戏流程中的交互**:
    
    - 任务完成时，TaskManager调用PlayerDataManager.Instance.Currencies.Add(Gold, 100)。
        
    - 玩家在商店点击购买，ShopPanel的UI脚本调用ShopManager.PurchaseItem("Hero_GuanYu")。
        
    - 购买成功或对局结束后，系统会自动调用PlayerDataManager.Instance.SavePlayerData()来保存进度。