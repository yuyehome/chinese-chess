# **《象棋荣耀》技术交接文档**

## **引言：核心架构理念**

本项目采用了一套现代化、高度解耦的架构，旨在实现以下核心目标：

1. **数据驱动 (Data-Driven)**: 游戏世界的一切都由一个纯数据容器 GameState 来描述。它是“唯一的事实来源 (Single Source of Truth)”。
    
2. **指令模式 (Command Pattern)**: 所有改变游戏状态的操作都必须封装成 ICommand 对象。这使得逻辑可追溯、可回放，并且天然适合网络同步。
    
3. 视图-逻辑分离 (MV Architecture)*: 游戏逻辑（Model）、视觉表现（View）和用户输入（Controller）被严格分离。这保证了代码的低耦合、高可维护性和易测试性。
    

**核心数据流**: **输入 -> 指令(Command) -> 处理器(Processor) -> 状态(GameState) -> 表现(View)**

---

## **第一部分：文件夹结构总览**

codeCode

```
Assets/
├── Scenes/               # 存放所有场景文件 (e.g., BattleScene, MainMenuScene)
├── Scripts/              # 存放所有C#脚本
│   ├── _Core/            # 游戏核心框架 (与具体游戏玩法、UI表现无关)
│   │   ├── Foundation/   # 最底层的工具类 (单例、常量等)
│   │   ├── Data/         # 纯数据结构定义 (棋子、玩家信息等)
│   │   ├── GameState/    # GameState 容器的定义
│   │   ├── Command/      # 指令接口、具体指令类及指令处理器
│   │   ├── GameModes/    # 可插拔的游戏模式规则逻辑
│   │   ├── Controller/   # 负责处理输入、驱动游戏循环的控制器
│   │   └── View/         # 负责将GameState渲染到屏幕上的视图类
│   ├── _Gameplay/        # 核心玩法层 (后续开发，如技能具体实现、AI逻辑)
│   └── _App/             # 应用与表现层 (UI管理器、场景加载、游戏总管等)
│       └── GameManagement/ # 游戏整体生命周期管理
├── Art/                  # 所有美术资源
├── Audio/                # 所有音频资源
├── Prefabs/              # 预制体 (e.g., PiecePrefab)
└── _Content/             # 存放 ScriptableObject 策划配置文件
    └── GameConfig/
```

---

## **第二部分：核心脚本文件索引**

|   |   |   |
|---|---|---|
|文件路径|脚本名称|核心职责|
|**_Core/Foundation/**|Singleton<T>.cs|线程安全的MonoBehaviour单例基类。|
||PersistentSingleton<T>.cs|跨场景不销毁的单例基类。|
||GameConstants.cs|存放全局游戏常量，如棋盘尺寸、行动点恢复速率。|
|**_Core/Data/**|DataEnums.cs|定义核心枚举，如PlayerTeam, PieceType, PieceStatus。|
||GameData.cs|定义核心纯数据结构，如PieceData, PlayerProfile。|
|**_Content/GameConfig/**|GameBalanceConfig.cs|(ScriptableObject) 游戏平衡数值配置。|
||HeroConfig.cs|(ScriptableObject) 武将基础信息配置。|
||SkillConfig.cs|(ScriptableObject) 技能基础信息配置。|
|**_Core/GameState/**|GameState.cs|游戏世界唯一数据快照，包含所有棋子、玩家数据。|
|**_Core/Command/**|ICommand.cs|所有指令的契约/接口，定义了Execute方法。|
||MoveCommand.cs|封装“移动棋子”操作的具体指令。|
||UseSkillCommand.cs|(框架) 封装“使用技能”操作的具体指令。|
||EndTurnCommand.cs|(框架) 封装“结束回合”操作的具体指令。|
||CommandProcessor.cs|**逻辑心脏**。接收、验证、执行指令，并更新GameState。|
|**_Core/GameModes/**|GameModeType.cs|枚举，用于标识不同游戏模式。|
||IGameModeLogic.cs|游戏模式规则的契约/接口。|
||RealTimeLogic.cs|IGameModeLogic的实现，包含实时模式的规则。|
||GameModeManager.cs|工厂类，用于根据GameModeType创建对应的规则实例。|
|**_Core/View/**|PieceView.cs|单个棋子在3D场景中的视觉表现，负责平滑移动等。|
||BoardView.cs|棋盘总视图，根据GameState创建、更新、销毁PieceView。|
|**_Core/Controller/**|InputController.cs|监听玩家输入（鼠标点击），并将其转换为ICommand。|
|**_App/GameManagement/**|GameLoopController.cs|**游戏粘合剂**。负责在场景中初始化并连接所有核心系统。|

---

## **第三部分：核心模块详解**

### **3.1 基础层 (_Core/Foundation & _Core/Data)**

- **设计目标**: 提供全项目通用的数据结构和工具。
    
- **核心理念**:
    
    - 数据结构（PieceData, PlayerProfile等）是纯C#类/结构体，不依赖Unity（MonoBehaviour），便于序列化和网络传输。
        
    - 游戏配置（GameBalanceConfig等）使用 ScriptableObject 实现，允许策划在Unity Editor中直接修改游戏数值，无需改动代码。
        
- **工作流**:
    
    - 当需要新的全局管理器时，应继承自 Singleton 或 PersistentSingleton。
        
    - 当需要策划配置新数值时，应创建新的 ScriptableObject 类，并在 _Content/GameConfig 目录下创建实例。
        

### **3.2 核心循环 (_Core/GameState & _Core/Command)**

- **设计目标**: 建立一个确定性的、可追溯的游戏逻辑处理核心。
    
- **核心理念**:
    
    - GameState 是唯一的数据源。任何逻辑判断都必须基于它。任何渲染表现都必须反映它。
        
    - CommandProcessor 是唯一的逻辑执行者。**任何对GameState的修改都必须通过CommandProcessor.ProcessCommand()来完成**。
        
- **工作流 (如何添加一个新的玩家动作，例如“弃子”)**:
    
    1. 在 _Core/Command/ 目录下创建 SurrenderCommand.cs，实现 ICommand 接口。
        
    2. 在 Execute 方法中，编写修改 GameState 的逻辑（例如，设置 state.phase = GamePhase.GameOver; 和 state.winner）。
        
    3. 在 InputController (或未来的UI按钮) 中，当玩家触发弃子操作时，创建一个 SurrenderCommand 实例。
        
    4. 调用 GameLoopController.Instance.RequestProcessCommand(command) 将指令发送给处理器。
        

### **3.3 规则与表现分离 (_Core/GameModes, _Core/Controller, _Core/View)**

- **设计目标**: 将游戏规则、玩家输入和视觉表现彻底解耦。
    
- **核心理念**:
    
    - **IGameModeLogic (规则层)**: 这是一个“规则插件”。它定义了在特定模式下“什么能做，什么不能做”（ValidateCommand），以及随时间会发生什么（OnTick）。
        
    - **InputController (输入层)**: 它的唯一职责是“翻译”。将玩家的原始输入（点击屏幕）翻译成游戏意图（MoveCommand）。它不包含任何游戏规则。
        
    - **View (表现层)**: 它的唯一职责是“渲染”。它订阅 CommandProcessor 的 OnGameStateUpdated 事件，当 GameState 变化时，它忠实地将新状态呈现出来。**View层永远不应直接修改GameState**。
        
- **工作流 (一个完整的移动操作流程)**:
    
    1. InputController 检测到鼠标点击，创建 MoveCommand。
        
    2. CommandProcessor 收到指令，调用 RealTimeLogic.ValidateCommand() 检查行动点是否足够。
        
    3. 验证通过，MoveCommand.Execute() 修改 GameState 中对应 PieceData 的 position。
        
    4. CommandProcessor 触发 OnGameStateUpdated 事件。
        
    5. BoardView 监听到事件，找到对应的 PieceView，并调用其 UpdateTargetPosition()。
        
    6. PieceView 在自己的 Update() 方法中，使用 Vector3.Lerp 平滑地将棋子的 transform.position 移动到新目标点，形成动画。
        

---

**文档维护说明**:  
本篇文档将在项目开发过程中持续更新。当添加新的核心系统或对现有架构进行重大修改时，请务及时更新本文档对应模块的内容。