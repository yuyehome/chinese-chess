# **《象棋荣耀》技术交接文档 (v2.0)**

## **引言：核心架构理念**

本项目采用了一套现代化、高度解耦的架构，旨在实现以下核心目标：

1. **数据驱动 (Data-Driven)**: 游戏世界的一切都由一个纯数据容器 GameState 来描述。它是“唯一的事实来源 (Single Source of Truth)”。
    
2. **指令模式 (Command Pattern)**: 所有改变游戏状态的操作都必须封装成 ICommand 对象。这使得逻辑可追溯、可回放，并且天然适合网络同步。
    
3. **视图-逻辑分离 (MV Architecture)**: 游戏逻辑（Model）、视觉表现（View）和用户输入（Controller）被严格分离。这保证了代码的低耦合、高可维护性和易测试性。
    

**核心数据流 (网络环境)**: **客户端输入 -> 网络指令(NetworkCommand) -> [网络] -> Host端接收 -> 逻辑指令(ICommand) -> 处理器(Processor) -> 权威状态(GameState) -> [网络RPC] -> 客户端接收 -> 状态应用 -> 表现(View)**

---

## **第一部分：文件夹结构总览**


Assets/
├── Scenes/               # 存放所有场景文件 (e.g., BattleScene, MainMenuScene)
├── Scripts/              # 存放所有C#脚本
│   ├── _Core/            # 游戏核心框架 (与具体游戏玩法、UI表现无关)
│   │   ├── Foundation/   # 最底层的工具类 (单例、常量等)
│   │   ├── Data/         # 纯数据结构定义 (棋子、玩家信息等)
│   │   ├── GameState/    # GameState 容器的定义
│   │   ├── Command/      # 指令接口、具体指令类及指令处理器
│   │   ├── GameModes/    # 可插拔的游戏模式规则逻辑
│   │   ├── Networking/   # 网络抽象层与具体实现
│   │   ├── Audio/        # 音效管理系统
│   │   ├── Localization/ # 国际化系统
│   │   ├── Controller/   # 负责处理输入、驱动游戏循环的控制器
│   │   └── View/         # 负责将GameState渲染到屏幕上的视图类
│   ├── _Gameplay/        # 核心玩法层 (后续开发，如技能具体实现、AI逻辑)
│   └── _App/             # 应用与表现层 (UI管理器、场景加载、游戏总管等)
│       └── GameManagement/ # 游戏整体生命周期管理
├── Art/                  # 所有美术资源
├── Audio/                # 所有音频资源
├── Prefabs/              # 预制体 (e.g., PiecePrefab, NetworkEvents)
└── _Content/             # 存放 ScriptableObject 策划配置文件
    ├── GameConfig/       # 游戏玩法数值配置 (e.g., HeroConfig, SkillConfig)
    ├── Audio/            # 音频数据配置 (e.g., GameAudioData)
    └── Localization/     # 国际化数据配置 (e.g., Language_Text_ZH_CN)


---

## **第二部分：核心脚本文件索引**

|                          |                           |                                                |
| ------------------------ | ------------------------- | ---------------------------------------------- |
| 文件路径                     | 脚本名称                      | 核心职责                                           |
| **_Core/Foundation/**    | Singleton<T>.cs           | 线程安全的MonoBehaviour单例基类。                        |
|                          | PersistentSingleton<T>.cs | 跨场景不销毁的单例基类。                                   |
| **_Core/Data/**          | DataEnums.cs              | 定义核心枚举，如PlayerTeam, PieceType, PieceStatus。    |
|                          | GameData.cs               | 定义核心纯数据结构，如PieceData, PlayerProfile。           |
| **_Core/GameState/**     | GameState.cs              | 游戏世界唯一数据快照，包含所有棋子、玩家数据。                        |
| **_Core/Command/**       | ICommand.cs               | 所有逻辑指令的接口，定义了Execute方法。                        |
|                          | MoveCommand.cs            | 封装“移动棋子”操作的具体逻辑指令。                             |
|                          | CommandProcessor.cs       | **逻辑心脏**。在Host端接收、验证、执行指令，并更新权威GameState。      |
| **_Core/GameModes/**     | IGameModeLogic.cs         | 游戏模式规则的接口，用于指令验证和游戏进程推进。                       |
|                          | GameModeManager.cs        | 工厂类，用于根据游戏模式创建对应的规则实例。                         |
| **_Core/Networking/**    | INetworkService.cs        | **网络层抽象接口**。解耦游戏逻辑与具体网络框架(Mirror)。             |
|                          | MirrorService.cs          | INetworkService的Mirror实现，管理网络连接与消息收发。          |
|                          | OfflineService.cs         | INetworkService的单机实现，用于无网络环境的开发与测试。            |
|                          | NetworkData.cs            | 定义用于网络传输的数据结构，如NetworkCommand。                 |
|                          | NetworkEvents.cs          | **网络事件中心**。一个网络对象，负责将Host的状态变更以RPC形式广播给客户端。    |
|                          | NetworkServiceProvider.cs | 服务定位器，为上层逻辑提供INetworkService的全局唯一实例。           |
| **_Core/Audio/**         | AudioData.cs              | (ScriptableObject) 定义音频Key与AudioClip的映射关系。     |
|                          | AudioManager.cs           | **音效服务**。管理BGM和SFX的播放，提供全局音量控制和音效池。            |
| **_Core/Localization/**  | LocalizationData.cs       | (ScriptableObject) 定义国际化Key与文本/资源(Asset)的映射关系。 |
|                          | LocalizationManager.cs    | **国际化服务**。管理语言切换，提供获取本地化文本和资源的接口。              |
|                          | LocalizedText.cs          | (UI组件) 挂载到Text/TextMeshProUGUI上，使其文本根据Key自动更新。 |
|                          | LocalizedImage.cs         | (UI组件) 挂载到Image上，使其Sprite根据Key自动更新。            |
| **_Core/View/**          | PieceView.cs              | 单个棋子在3D场景中的视觉表现。                               |
|                          | BoardView.cs              | 棋盘总视图，根据GameState的变更创建、更新、销毁PieceView。         |
| **_Core/Controller/**    | InputController.cs        | (客户端)监听玩家输入，将其转换为NetworkCommand并通过网络服务发送。      |
| **_App/GameManagement/** | GameLoopController.cs     | **游戏粘合剂**。初始化各核心系统，作为Host权威逻辑与客户端表现的中央协调者。     |

---

## **第三部分：核心模块详解**

### **3.1 基础层 (_Core/Foundation & _Core/Data)**

- **设计目标**: 提供全项目通用的数据结构和工具。
    
- **核心理念**:
    
    - 数据结构（PieceData, PlayerProfile等）是纯C#类/结构体，不依赖Unity，便于序列化和网络传输。
        
    - 为需要在网络间传输的自定义结构体（如PieceData），在 NetworkSerializers.cs 中提供对应的序列化扩展方法。
        

### **3.2 核心循环 (_Core/GameState & _Core/Command)**

- **设计目标**: 建立一个**仅在Host端运行**的、确定性的、可追溯的游戏逻辑处理核心。
    
- **核心理念**:
    
    - Host端的 GameState 是唯一权威的数据源。所有逻辑计算和裁决都必须基于它。
        
    - CommandProcessor 是唯一的逻辑执行者，**任何对权威GameState的修改都必须通过它在Host端完成**。
        
    - 客户端拥有一个 GameState 的本地镜像，该镜像**只能**通过接收来自Host的网络事件(RPC)来更新。
        

### **3.3 网络层 (_Core/Networking)**

- **设计目标**: 构建一个健壮、高效、可扩展的网络层，采用权威服务器模型。
    
- **核心理念**:
    
    - **网络抽象 (INetworkService)**: 上层逻辑（如InputController）通过此接口与网络交互，无需关心底层是Mirror还是未来的其他框架。
        
    - **指令驱动 (NetworkCommand)**: 客户端将操作意图封装成纯数据的NetworkCommand发送给Host，而非直接尝试修改状态。
        
    - **事件同步 (NetworkEvents)**: Host在权威逻辑处理完毕后，不直接同步整个GameState，而是将原子化的“状态变更事件”（如棋子移动、棋子死亡）通过NetworkEvents对象的RPC广播给所有客户端。
        
- **关键组件**:
    
    - MirrorService: 继承自Mirror的NetworkManager，是网络功能的具体实现者。
        
    - NetworkPlayer: 每个连接客户端时，Host会为其生成一个NetworkPlayer实例。该实例的OnStartServer是触发对新客户端进行“初始全盘状态同步”的最佳时机。
        
    - NetworkEvents: 这是一个在场景中唯一的、被NetworkServer.Spawn的网络对象。Host通过调用它的[ClientRpc]方法来广播事件，客户端通过接收这些RPC来更新自己的游戏世界。
        

### **3.4 规则与表现分离 (_Core/GameModes, _Core/Controller, _Core/View)**

- **设计目标**: 将游戏规则、玩家输入和视觉表现彻底解耦，使其在网络环境中清晰工作。
    
- **核心理念**:
    
    - **InputController (输入层)**: **仅在客户端**工作。职责是“翻译”，将玩家的原始输入（点击）翻译成NetworkCommand，然后通过INetworkService发送出去。
        
    - **GameLoopController (粘合层)**:
        
        - **在Host端**，它初始化CommandProcessor，监听其C#事件（如OnPieceUpdated），并将这些事件**翻译**成NetworkEvents的RPC调用。同时，它也直接更新Host本地的BoardView。
            
        - **在Client端**，它提供一系列Handle...FromNet方法，这些方法被NetworkEvents的RPC所调用，用于接收网络事件并更新本地的GameState和BoardView。
            
    - **View (表现层)**: 其职责是“渲染”。它被GameLoopController驱动，忠实地将本地GameState的状态呈现出来。
        

### **3.5 核心工作流 (一个完整的网络移动操作)**

1. **客户端 - 输入**: 玩家点击棋子和目标点。InputController捕获输入，创建一个填充了pieceId和targetPosition的NetworkCommand。
    
2. **客户端 - 发送**: InputController调用NetworkServiceProvider.Instance.SendCommandToServer(cmd)。客户端的MirrorService将此NetworkCommand通过网络发送给Host。
    
3. **Host端 - 接收与解析**: Host端的MirrorService在OnServerReceiveCommand中收到NetworkCommand。它将这个网络数据结构**反向解析**为一个逻辑层的ICommand实例（例如 new MoveCommand(...)）。
    
4. **Host端 - 权威处理**: MirrorService调用GameLoopController.RequestProcessCommand(logicCmd)。GameLoopController确认自己是权威(Host)，将指令交给CommandProcessor。
    
5. **Host端 - 状态变更与本地更新**: CommandProcessor通过IGameModeLogic验证指令（如行动点），验证通过后执行指令，修改**权威GameState**。这会触发CommandProcessor的C#事件（如OnPieceUpdated）。
    
6. **Host端 - 广播与本地视图更新**: GameLoopController的事件处理器HandlePieceUpdated被调用。它会做两件事：  
    a. **立即更新本地视图**: 调用boardView.OnPieceUpdated()，使Host玩家能立刻看到移动效果。  
    b. **广播给客户端**: 调用NetworkEvents.Instance.RpcOnPieceUpdated()，将PieceData通过RPC广播给所有其他客户端。
    
7. **客户端 - 接收与应用**: 其他客户端的NetworkEvents实例接收到RpcOnPieceUpdated调用。
    
8. **客户端 - 状态与视图更新**: NetworkEvents调用GameLoopController.HandlePieceUpdated_FromNet()。该方法更新客户端的**本地GameState镜像**，并调用boardView.OnPieceUpdated()来驱动PieceView播放移动动画。
    
### **3.6 音效系统 (_Core/Audio)**

- **设计目标**: 提供一个中心化的服务来管理和播放所有背景音乐(BGM)和音效(SFX)。
    
- **核心理念**:
    
    - **数据驱动 (AudioData.cs)**: 使用ScriptableObject将音效的**唯一标识Key**(如 "sfx_piece_move")与具体的AudioClip文件进行解耦。音效师和策划可以在不修改代码的情况下增删和替换游戏音效。
        
    - **中心化服务 (AudioManager.cs)**: 作为PersistentSingleton存在，提供全局唯一的音效播放入口。它内部管理着一个专门用于循环播放BGM的AudioSource和一个用于高频播放SFX的AudioSource对象池，以优化性能。
        
    - **专业混音 (Audio Mixer)**: AudioManager不直接控制音量，而是通过设置Unity的Audio Mixer中暴露的参数（如 "BGMVolume"）来控制。这使得音量管理和未来添加全局音效（如混响）变得简单。
        
- **工作流 (播放一个棋子移动音效)**:
    
    1. 在_Content/Audio/目录下，策划在AudioData配置文件中添加一个条目，Key为"sfx_piece_move"，并将对应的音效文件拖入。
        
    2. 游戏启动时，AudioManager加载所有AudioData，将Key-Clip映射缓存到字典中。
        
    3. 在PieceView.cs中，当棋子开始移动时，代码调用 AudioManager.Instance.PlaySFX("sfx_piece_move");。
        
    4. AudioManager根据Key找到对应的AudioClip，从对象池中取出一个空闲的AudioSource，调用PlayOneShot()播放音效。
        

### **3.7 国际化系统 (_Core/Localization)**

- **设计目标**: 使游戏内的所有文本和部分资源能够根据当前选择的语言自动切换。
    
- **核心理念**:
    
    - **数据驱动 (LocalizationData.cs)**: 为**每种语言**创建一个ScriptableObject数据文件（如Language_Text_ZH_CN.asset）。该文件存储了该语言环境下所有文本/资源的Key-Value映射。这使得添加新语言或修改翻译无需重编译代码。
        
    - **中心化服务 (LocalizationManager.cs)**: PersistentSingleton单例，负责加载所有语言的数据，管理当前语言的切换，并提供GetText(key)和GetAsset<T>(key)等核心接口。

	- **自动化UI组件 (LocalizedText.cs, LocalizedImage.cs)**: 这些辅助组件可以直接挂载到Unity的UI元素上。开发者只需在Inspector中为其指定一个localizationKey，这些组件就会自动订阅LocalizationManager的语言切换事件，并在语言变化时自动刷新显示内容。
        
- **工作流 (更新一个UI按钮的文本)**:
    
    1. 在_Content/Localization/目录下，翻译人员在Language_Text_ZH_CN.asset中添加条目 {Key: "confirm_button", Value: "确认"}，在Language_Text_EN_US.asset中添加 {Key: "confirm_button", Value: "Confirm"}。
        
    2. UI开发者将LocalizedText组件挂载到按钮的Text组件旁边，并在localizationKey字段填入"confirm_button"。
        
    3. 游戏运行时，LocalizedText组件会自动调用LocalizationManager.Instance.GetText("confirm_button")来设置文本。
        
    4. 当玩家在设置菜单中切换语言，触发LocalizationManager.Instance.SetLanguage()时，OnLanguageChanged事件被广播，所有LocalizedText组件收到事件后，会再次获取文本并刷新，UI界面瞬间完成语言切换。


---

