# **《象棋荣耀》技术交接文档 (v2.0)**

## **引言：核心架构理念**

本项目采用了一套现代化、高度解耦的架构，旨在实现以下核心目标：

1. **数据驱动 (Data-Driven)**: 游戏世界的一切都由一个纯数据容器 GameState 来描述。它是“唯一的事实来源 (Single Source of Truth)”。
    
2. **指令模式 (Command Pattern)**: 所有改变游戏状态的操作都必须封装成 ICommand 对象。这使得逻辑可追溯、可回放，并且天然适合网络同步。
    
3. **视图-逻辑分离 (MV Architecture)**: 游戏逻辑（Model）、视觉表现（View）和用户输入（Controller）被严格分离。这保证了代码的低耦合、高可维护性和易测试性。
    

**核心数据流 (网络环境)**: **客户端输入 -> 网络指令(NetworkCommand) -> [网络] -> Host端接收 -> 逻辑指令(ICommand) -> 处理器(Processor) -> 权威状态(GameState) -> [网络RPC] -> 客户端接收 -> 状态应用 -> 表现(View)**

---

## **第一部分：文件夹结构总览**


Assets/
├── Scenes/               # 存放所有场景文件 (e.g., BattleScene, MainMenuScene)
├── Scripts/              # 存放所有C#脚本
│   ├── _Core/            # 游戏核心框架 (与具体游戏玩法、UI表现无关)
│   │   ├── Foundation/   # 最底层的工具类 (单例、常量等)
│   │   ├── Data/         # 纯数据结构定义 (棋子、玩家信息等)
│   │   ├── GameState/    # GameState 容器的定义
│   │   ├── Command/      # 指令接口、具体指令类及指令处理器
│   │   ├── GameModes/    # 可插拔的游戏模式规则逻辑
│   │   ├── Networking/   # 网络抽象层与具体实现
│   │   ├── Audio/        # 音效管理系统
│   │   ├── Localization/ # 国际化系统
│   │   ├── Controller/   # 负责处理输入、驱动游戏循环的控制器
│   │   └── View/         # 负责将GameState渲染到屏幕上的视图类
│   ├── _Gameplay/        # 核心玩法层 (后续开发，如技能具体实现、AI逻辑)
│   │   ├── Rules/            # 纯粹的、无状态的游戏规则计算库
│   │   └── TurnBased/        # 回合制模式的特有逻辑
│   └── _App/             # 应用与表现层 (UI管理器、场景加载、游戏总管等)
│       └── GameManagement/ # 游戏整体生命周期管理
│       ├── Scenes/         # 场景特有的控制器脚本
│       └── UI/             # UI系统
│           ├── Panels/     #  具体的UI面板逻辑脚本
│           └── Views/      #  可复用的UI组件/视图逻辑脚本
├── Resources/                #  存放所有需要通过 Resources.Load 动态加载的资源
│   ├── Materials/            # 材质，按皮肤和类型组织
│   │   └── Pieces/
│   │       └── Wood/
│   └── ... (其他未来可能需要动态加载的资源)
├── Art/                  # 所有美术资源
│   ├── Models/
│   └── Textures/
├── Audio/                # 所有音频资源
├── Prefabs/              # 预制体 (e.g., PiecePrefab, NetworkEvents)
│   ├── UI/               # UI相关的Prefab
│   │   ├── Panels/       #  UI面板的Prefab
│   │   └── Views/        #  可复用UI组件的Prefab
└── _Content/             # 存放 ScriptableObject 策划配置文件
    ├── GameConfig/       # 游戏玩法数值配置 (e.g., HeroConfig, SkillConfig)
    ├── Audio/            # 音频数据配置 (e.g., GameAudioData)
    └── Localization/     # 国际化数据配置 (e.g., Language_Text_ZH_CN)


---

## **第二部分：所有脚本文件索引**

├── Scripts/              # 存放所有C#脚本
│   ├── _Core/            # 游戏核心框架 (与具体游戏玩法、UI表现无关)
│   │   ├── Foundation/   # 最底层的工具类 (单例、常量等)
│   │   │   ├── Singleton.cs              # 线程安全的MonoBehaviour单例基类。
│   │   │   └── PersistentSingleton.cs    # 跨场景不销毁的单例基类。
│   │   ├── Data/         # 纯数据结构定义 (棋子、玩家信息等)
│   │   │   ├── DataEnums.cs              # 定义核心枚举，如PlayerTeam, PieceType, PieceStatus。
│   │   │   └── GameData.cs               # 定义核心纯数据结构，如PieceData, PlayerProfile。
│   │   ├── GameState/    # GameState 容器的定义
│   │   │   └── GameState.cs              # 游戏世界唯一数据快照，包含所有棋子、玩家数据。
│   │   ├── Command/      # 指令接口、具体指令类及指令处理器
│   │   │   ├── ICommand.cs               # 所有逻辑指令的接口，定义了Execute方法。
│   │   │   ├── MoveCommand.cs            # 封装“移动棋子”操作的具体逻辑指令。
│   │   │   ├── RequestDrawCommand.cs     # 封装“请求和棋”操作的具体逻辑指令。
│   │   │   ├── AcceptDrawCommand.cs      # 封装“接受和棋”操作的具体逻辑指令。
│   │   │   ├── EndTurnCommand.cs         # 封装“回合结束”操作的具体逻辑指令。
│   │   │   ├── ResignCommand.cs          # 封装“投降”操作的具体逻辑指令。
│   │   │   ├── UseSkillCommand.cs        # TODO
│   │   │   └── CommandProcessor.cs       # 逻辑心脏。在Host端接收、验证、执行指令，并更新权威GameState。
│   │   ├── GameModes/    # 可插拔的游戏模式规则逻辑
│   │   │   ├── IGameModeLogic.cs         # 游戏模式规则的接口，用于指令验证和游戏进程推进。
│   │   │   ├── GameModeManager.cs        # 工厂类，用于根据游戏模式创建对应的规则实例。
│   │   │   ├── GameModeType.cs           # 游戏模式的枚举定义。
│   │   │   └── RealTimeLogic.cs          # TODO
│   │   ├── Networking/   # 网络抽象层与具体实现
│   │   │   ├── INetworkService.cs        # 网络层抽象接口。解耦游戏逻辑与具体网络框架(Mirror)。
│   │   │   ├── MirrorService.cs          # INetworkService的Mirror实现，管理网络连接与消息收发。
│   │   │   ├── OfflineService.cs         # INetworkService的单机实现，用于无网络环境的开发与测试。
│   │   │   ├── NetworkData.cs            # 定义用于网络传输的数据结构，如NetworkCommand。
│   │   │   ├── NetworkEvents.cs          # 网络事件中心。一个网络对象，负责将Host的状态变更以RPC形式广播给客户端。
│   │   │   ├── NetworkSerializers.cs     # 为自定义数据类型提供网络序列化/反序列化方法。
│   │   │   └── NetworkServiceProvider.cs # 服务定位器，为上层逻辑提供INetworkService的全局唯一实例。
│   │   ├── Audio/        # 音效管理系统
│   │   │   ├── AudioData.cs              # (ScriptableObject) 定义音频Key与AudioClip的映射关系。
│   │   │   └── AudioManager.cs           # 音效服务。管理BGM和SFX的播放，提供全局音量控制和音效池。
│   │   ├── Localization/ # 国际化系统
│   │   │   ├── LocalizationData.cs       # (ScriptableObject) 定义国际化Key与文本/资源(Asset)的映射关系。
│   │   │   ├── LocalizationManager.cs    # 国际化服务。管理语言切换，提供获取本地化文本和资源的接口。
│   │   │   ├── LocalizedText.cs          # (UI组件) 挂载到Text/TextMeshProUGUI上，使其文本根据Key自动更新。
│   │   │   └── LocalizedImage.cs         # (UI组件) 挂载到Image上，使其Sprite根据Key自动更新。
│   │   ├── Controller/   # 负责处理输入、驱动游戏循环的控制器
│   │   │   └── InputController.cs        # (客户端)监听玩家输入，将其转换为NetworkCommand并通过网络服务发送。
│   │   └── View/         # 负责将GameState渲染到屏幕上的视图类
│   │       ├── PieceView.cs              # 单个棋子在3D场景中的视觉表现。
│   │       ├── BoardView.cs              # 棋盘总视图，根据GameState的变更创建、更新、销毁PieceView。
│   │       └── BoardGridRenderer.cs      # 视觉表现。负责程序化地绘制棋盘网格线及开局动画。
│   ├── _Gameplay/        # 核心玩法层 (后续开发，如技能具体实现、AI逻辑)
│   │   └── Rules/        # 纯粹的、无状态的游戏规则计算库
│   │       └── PieceMovementGenerator.cs # 规则库。一个纯静态类，用于计算各种棋子在理论上的所有移动可能性。
│   └── _App/             # 应用与表现层 (UI管理器、场景加载、游戏总管等)
│       ├── GameManagement/ # 游戏整体生命周期管理
│       │   ├── GameLoopController.cs     # 游戏粘合剂。初始化各核心系统，作为Host权威逻辑与客户端表现的中央协调者。
│       │   └── SkinManager.cs            # 皮肤服务。管理所有棋子皮肤材质的加载、缓存和供应。
│       ├── Scenes/         # (新增) 场景特有的控制器脚本
│       │   └── MainMenuController.cs     # MainMenuScene的场景入口与控制器。负责初始化该场景的UI和系统，并提供测试入口。
│       └── UI/             # (新增) UI系统
│           ├── UIPanel.cs                # 所有UI面板的抽象基类，提供Setup, Show, Hide等生命周期方法。
│           ├── UIManager.cs              # UI系统核心管理器。负责所有UIPanel的生命周期（实例化、显示、隐藏），采用单例模式。
│           ├── Panels/     # (新增) 具体的UI面板逻辑脚本
│           │   ├── MainMenuPanel.cs        # 主菜单面板。负责展示游戏核心入口（排位、闯关等）按钮，并集成PlayerInfoView。
│           │   └── RoomPanel.cs            # 游戏房间面板。采用状态驱动设计，管理“等待中”和“备战-抢棋子”等多个阶段的UI显示与交互。
│           └── Views/      # (新增) 可复用的UI组件/视图逻辑脚本
│               ├── PlayerInfoView.cs       # 玩家信息视图。一个可复用的UI组件，用于在主菜单顶部显示玩家头像、昵称、金币等信息。
│               ├── PlayerSlotView.cs       # 玩家槽位视图。用于RoomPanel的可复用组件，显示单个玩家的信息、延迟、高亮状态，并包含其“已选棋子”的显示区域。
│               └── PieceSelectionButton.cs # 棋子选择按钮。用于RoomPanel备战阶段的动态棋子图标，封装了自身的棋子数据和点击事件。
│   └── _Content/             # 存放 ScriptableObject 策划配置文件
│       ├── GameConfig/       # 游戏玩法数值配置
│       │   ├── BoardConfig.cs            # (ScriptableObject) 定义棋盘的物理尺寸、格子间距和坐标转换方法。
│       │   ├── PieceSkinData.cs          # (ScriptableObject) 定义棋子皮肤图集的UV分割数据。
│       │   ├── GameBalanceConfig.cs      # (TODO)
│       │   ├── HeroConfig.cs             # (TODO)
│       │   └── SkillConfig.cs            # (TODO)
│       ├── Audio/            # 音频数据配置
│       │   └── GameAudioData.cs          # (ScriptableObject) 音频数据配置
│       └── Localization/     # 国际化数据配置
│           └── Language_Text_ZH_CN.cs    # (ScriptableObject) 国际化数据配置

---

## **第三部分：核心模块详解**

### **3.1 基础层 (_Core/Foundation & _Core/Data)**

- **设计目标**: 提供全项目通用的数据结构和工具。
    
- **核心理念**:
    
    - 数据结构（PieceData, PlayerProfile等）是纯C#类/结构体，不依赖Unity，便于序列化和网络传输。
        
    - 为需要在网络间传输的自定义结构体（如PieceData），在 NetworkSerializers.cs 中提供对应的序列化扩展方法。
        

### **3.2 核心循环 (_Core/GameState & _Core/Command)**

- **设计目标**: 建立一个**仅在Host端运行**的、确定性的、可追溯的游戏逻辑处理核心。
    
- **核心理念**:
    
    - Host端的 GameState 是唯一权威的数据源。所有逻辑计算和裁决都必须基于它。
        
    - CommandProcessor 是唯一的逻辑执行者，**任何对权威GameState的修改都必须通过它在Host端完成**。
        
    - 客户端拥有一个 GameState 的本地镜像，该镜像**只能**通过接收来自Host的网络事件(RPC)来更新。
        

### **3.3 网络层 (_Core/Networking)**

- **设计目标**: 构建一个健壮、高效、可扩展的网络层，采用权威服务器模型。
    
- **核心理念**:
    
    - **网络抽象 (INetworkService)**: 上层逻辑（如InputController）通过此接口与网络交互，无需关心底层是Mirror还是未来的其他框架。
        
    - **指令驱动 (NetworkCommand)**: 客户端将操作意图封装成纯数据的NetworkCommand发送给Host，而非直接尝试修改状态。
        
    - **事件同步 (NetworkEvents)**: Host在权威逻辑处理完毕后，不直接同步整个GameState，而是将原子化的“状态变更事件”（如棋子移动、棋子死亡）通过NetworkEvents对象的RPC广播给所有客户端。
        
- **关键组件**:
    
    - MirrorService: 继承自Mirror的NetworkManager，是网络功能的具体实现者。
        
    - NetworkPlayer: 每个连接客户端时，Host会为其生成一个NetworkPlayer实例。该实例的OnStartServer是触发对新客户端进行“初始全盘状态同步”的最佳时机。
        
    - NetworkEvents: 这是一个在场景中唯一的、被NetworkServer.Spawn的网络对象。Host通过调用它的[ClientRpc]方法来广播事件，客户端通过接收这些RPC来更新自己的游戏世界。
        

### **3.4 规则与表现分离 (_Core/GameModes, _Core/Controller, _Core/View)**

- **设计目标**: 将游戏规则、玩家输入和视觉表现彻底解耦，使其在网络环境中清晰工作。
    
- **核心理念**:
    
    - **InputController (输入层)**: **仅在客户端**工作。职责是“翻译”，将玩家的原始输入（点击）翻译成NetworkCommand，然后通过INetworkService发送出去。
        
    - **GameLoopController (粘合层)**:
        
        - **在Host端**，它初始化CommandProcessor，监听其C#事件（如OnPieceUpdated），并将这些事件**翻译**成NetworkEvents的RPC调用。同时，它也直接更新Host本地的BoardView。
            
        - **在Client端**，它提供一系列Handle...FromNet方法，这些方法被NetworkEvents的RPC所调用，用于接收网络事件并更新本地的GameState和BoardView。
            
    - **View (表现层)**: 其职责是“渲染”。它被GameLoopController驱动，忠实地将本地GameState的状态呈现出来。
        

### **3.5 核心工作流 (一个完整的网络移动操作)**

1. **客户端 - 输入**: 玩家点击棋子和目标点。InputController捕获输入，创建一个填充了pieceId和targetPosition的NetworkCommand。
    
2. **客户端 - 发送**: InputController调用NetworkServiceProvider.Instance.SendCommandToServer(cmd)。客户端的MirrorService将此NetworkCommand通过网络发送给Host。
    
3. **Host端 - 接收与解析**: Host端的MirrorService在OnServerReceiveCommand中收到NetworkCommand。它将这个网络数据结构**反向解析**为一个逻辑层的ICommand实例（例如 new MoveCommand(...)）。
    
4. **Host端 - 权威处理**: MirrorService调用GameLoopController.RequestProcessCommand(logicCmd)。GameLoopController确认自己是权威(Host)，将指令交给CommandProcessor。
    
5. **Host端 - 状态变更与本地更新**: CommandProcessor通过IGameModeLogic验证指令（如行动点），验证通过后执行指令，修改**权威GameState**。这会触发CommandProcessor的C#事件（如OnPieceUpdated）。
    
6. **Host端 - 广播与本地视图更新**: GameLoopController的事件处理器HandlePieceUpdated被调用。它会做两件事：  
    a. **立即更新本地视图**: 调用boardView.OnPieceUpdated()，使Host玩家能立刻看到移动效果。  
    b. **广播给客户端**: 调用NetworkEvents.Instance.RpcOnPieceUpdated()，将PieceData通过RPC广播给所有其他客户端。
    
7. **客户端 - 接收与应用**: 其他客户端的NetworkEvents实例接收到RpcOnPieceUpdated调用。
    
8. **客户端 - 状态与视图更新**: NetworkEvents调用GameLoopController.HandlePieceUpdated_FromNet()。该方法更新客户端的**本地GameState镜像**，并调用boardView.OnPieceUpdated()来驱动PieceView播放移动动画。
    
### **3.6 音效系统 (_Core/Audio)**

- **设计目标**: 提供一个中心化的服务来管理和播放所有背景音乐(BGM)和音效(SFX)。
    
- **核心理念**:
    
    - **数据驱动 (AudioData.cs)**: 使用ScriptableObject将音效的**唯一标识Key**(如 "sfx_piece_move")与具体的AudioClip文件进行解耦。音效师和策划可以在不修改代码的情况下增删和替换游戏音效。
        
    - **中心化服务 (AudioManager.cs)**: 作为PersistentSingleton存在，提供全局唯一的音效播放入口。它内部管理着一个专门用于循环播放BGM的AudioSource和一个用于高频播放SFX的AudioSource对象池，以优化性能。
        
    - **专业混音 (Audio Mixer)**: AudioManager不直接控制音量，而是通过设置Unity的Audio Mixer中暴露的参数（如 "BGMVolume"）来控制。这使得音量管理和未来添加全局音效（如混响）变得简单。
        
- **工作流 (播放一个棋子移动音效)**:
    
    1. 在_Content/Audio/目录下，策划在AudioData配置文件中添加一个条目，Key为"sfx_piece_move"，并将对应的音效文件拖入。
        
    2. 游戏启动时，AudioManager加载所有AudioData，将Key-Clip映射缓存到字典中。
        
    3. 在PieceView.cs中，当棋子开始移动时，代码调用 AudioManager.Instance.PlaySFX("sfx_piece_move");。
        
    4. AudioManager根据Key找到对应的AudioClip，从对象池中取出一个空闲的AudioSource，调用PlayOneShot()播放音效。
        

### **3.7 国际化系统 (_Core/Localization)**

- **设计目标**: 使游戏内的所有文本和部分资源能够根据当前选择的语言自动切换。
    
- **核心理念**:
    
    - **数据驱动 (LocalizationData.cs)**: 为**每种语言**创建一个ScriptableObject数据文件（如Language_Text_ZH_CN.asset）。该文件存储了该语言环境下所有文本/资源的Key-Value映射。这使得添加新语言或修改翻译无需重编译代码。
        
    - **中心化服务 (LocalizationManager.cs)**: PersistentSingleton单例，负责加载所有语言的数据，管理当前语言的切换，并提供GetText(key)和GetAsset<T>(key)等核心接口。

	- **自动化UI组件 (LocalizedText.cs, LocalizedImage.cs)**: 这些辅助组件可以直接挂载到Unity的UI元素上。开发者只需在Inspector中为其指定一个localizationKey，这些组件就会自动订阅LocalizationManager的语言切换事件，并在语言变化时自动刷新显示内容。
        
- **工作流 (更新一个UI按钮的文本)**:
    
    1. 在_Content/Localization/目录下，翻译人员在Language_Text_ZH_CN.asset中添加条目 {Key: "confirm_button", Value: "确认"}，在Language_Text_EN_US.asset中添加 {Key: "confirm_button", Value: "Confirm"}。
        
    2. UI开发者将LocalizedText组件挂载到按钮的Text组件旁边，并在localizationKey字段填入"confirm_button"。
        
    3. 游戏运行时，LocalizedText组件会自动调用LocalizationManager.Instance.GetText("confirm_button")来设置文本。
        
    4. 当玩家在设置菜单中切换语言，触发LocalizationManager.Instance.SetLanguage()时，OnLanguageChanged事件被广播，所有LocalizedText组件收到事件后，会再次获取文本并刷新，UI界面瞬间完成语言切换。


### **3.8 皮肤系统 (_App/GameManagement/SkinManager & _Core/View/PieceView)**

- **设计目标**: 实现一个高效、可扩展的棋子皮肤系统，允许在不更换模型的情况下，通过更换材质和修改UV来改变棋子外观。
    
- **核心理念**:
    
    - **单一模型，多种外观**: 所有棋子共享同一个基础模型 (Piece_Base.fbx)，极大优化了性能和资源管理。
        
    - **数据驱动 (PieceSkinData.cs)**: 棋子图集的UV分割信息存储在 ScriptableObject 中，策划可配置，代码只负责读取和应用。
        
    - **中心化服务 (SkinManager.cs)**: 作为 PersistentSingleton，在游戏启动时预加载所有皮肤材质，为 PieceView 提供一个统一、高效的材质获取接口。材质按 SkinType 和 PlayerTeam 进行索引。
        
    - **视图自治 (PieceView.cs)**: 每个 PieceView 实例在被初始化时，会主动向 SkinManager 请求自己所需的材质，并根据 PieceSkinData 修改自身Mesh的UV坐标，完成“换肤”。为了不影响项目源文件，PieceView 会在内存中创建其Mesh的一个实例(_instancedMesh)进行操作。
        
- **工作流 (创建一个红色木纹“车”)**:
    
    1. GameLoopController 通知 BoardView 创建棋子。
        
    2. BoardView 实例化一个 Piece_Template.prefab，并调用其 PieceView 组件的 Initialize(pieceData) 方法。
        
    3. PieceView.Initialize 被调用，pieceData 中包含 { team: Red, type: Chariot }。
        
    4. PieceView 调用 SkinManager.Instance.GetPieceMaterial(SkinType.Wood, PlayerTeam.Red)，获得一个红色的木纹材质**实例**。
        
    5. PieceView 将此材质应用到自己的 MeshRenderer。
        
    6. PieceView 从其引用的 PieceSkinData 中，调用 GetUVRect(PieceType.Chariot)，获得“车”在图集中的UV区域 Rect。
        
    7. PieceView 创建自己Mesh的实例，并根据获取的 Rect 重新计算所有UV坐标，应用到实例化的Mesh上。棋子正确显示。
        

### **3.9 坐标系统 (_Content/GameConfig/BoardConfig)**

- **设计目标**: 将游戏的逻辑坐标（格子坐标，如 (0,0)）与场景中的物理坐标（世界坐标，如 (0.05, 0, 0.1)）完全解耦。
    
- **核心理念**:
    
    - **单一事实来源 (BoardConfig.cs)**: 所有关于棋盘物理尺寸的“真理”都存储在这个 ScriptableObject 中，包括格子间距(gridSpacing)、原点偏移(originOffset)等。
        
    - **中心化转换**: BoardConfig 提供了 GridToWorld() 和 WorldToGrid() 两个核心转换方法。所有需要进行坐标转换的脚本（如 BoardView, InputController）都必须通过它来完成，确保了全项目坐标系的高度统一。
        
    - **视图层持有**: BoardView 作为棋盘视觉表现的总管，持有对 BoardConfig 的引用，并可将其提供给其他需要坐标转换服务的脚本。

### **  3.10 UI 系统 (_App/UI)**

- **设计目标**: 构建一个可扩展、易于管理、状态驱动的UI框架，以支持主菜单、游戏房间等复杂界面的开发。
    
- **核心理念**:
    
    - **中心化管理 (UIManager)**: UIManager 作为 PersistentSingleton，是所有UI面板的唯一管理者。它通过持有UI Prefab列表来解耦UI的创建，并使用字典缓存实例化的面板以提高性能。
        
    - **面板基类 (UIPanel)**: 所有全屏或大型弹出面板（如MainMenuPanel, RoomPanel）都继承自 UIPanel，这统一了它们的生命周期接口（Setup, Show, Hide），使得面板的切换和控制逻辑高度一致。
        
    - **可复用视图 (Views)**: 将界面中重复出现的、功能独立的元素（如PlayerInfoView, PlayerSlotView）封装成独立的 MonoBehaviour 和 Prefab。这些视图组件不继承 UIPanel，由其所属的面板直接控制，实现了高度的模块化和复用性。
        
    - **状态驱动**: 复杂的面板（如 RoomPanel）内部通过切换不同的UI容器（GameObject）的显隐来实现状态机。例如，ShowWaitingState() 和 ShowPreBattleState() 方法会分别激活不同的UI层，使得各状态的UI逻辑清晰分离。
        
- **关键组件**:
    
    - **UIManager.cs**: UI系统的“大脑”。提供 ShowPanel<T>() 和 HidePanel<T>() 两个核心方法，是外部系统与UI交互的唯一入口。
        
    - **MainMenuController.cs**: 场景控制器，作为场景启动的“粘合剂”，负责调用 UIManager 来显示该场景的第一个UI面板。
        
    - **RoomPanel.cs**: 主菜单流程中的核心面板，展示了如何通过状态切换函数来管理复杂的UI交互流程，以及如何动态生成UI元素（棋子选择池）并为其添加动画支持。
        
- **核心工作流 (显示 RoomPanel 并进入备战)**:
    
    1. 游戏启动后，MainMenuController 调用 UIManager.Instance.ShowPanel<MainMenuPanel>()。
        
    2. 玩家在 MainMenuPanel 点击【房间】按钮。该按钮的事件会调用 UIManager.Instance.ShowPanel<RoomPanel>()。
        
    3. UIManager 实例化 RoomPanel.prefab，并调用其 Setup() 和 Show() 方法。
        
    4. RoomPanel 在 Show() 方法中，默认调用 ShowWaitingState()，显示玩家槽位和底部的“开始备战”按钮。
        
    5. 房主点击“开始备战”按钮。
        
    6. OnStartPreBattleClicked() 事件被触发，该方法调用 ShowPreBattleState()。
        
    7. ShowPreBattleState() 方法：  
        a. 隐藏底部的操作栏。  
        b. 动态实例化 PieceSelectionButton_Prefab 并填充到中央棋子池。  
        c. 播放 PreBattleView 的 CanvasGroup 渐显动画。  
        d. 动画结束后，启动第一回合的轮转和倒计时逻辑。
        
- **动画层 (AnimationLayer) 设计**:
    
    - 在 RoomPanel 中，为了实现棋子图标被选中后能“飞”向玩家区域并覆盖所有UI，设计了一个独立的 AnimationLayer。
        
    - AnimationLayer 是一个拥有更高 Sort Order 的独立 Canvas。
        
    - 当棋子图标开始飞行动画时，它的父对象会被临时设置为 AnimationLayer，使其渲染在最顶层。动画结束后，该飞行对象被销毁，同时在目标 PlayerSlotView 中生成一个静态的已选棋子图标。这确保了动画表现的流畅性和视觉正确性。

---

## **附录 A：美术资源管线规范 (v1.0)**

### **A.1 文件夹结构**

为确保资源的可查找性和代码引用的稳定性，所有美术资源必须遵循以下目录结构：

- **Assets/Art/**: 存放所有美术**源文件**，如 .blend, .psd, .spp 等，以及不需要被代码动态加载的模型和贴图文件。
    
    - Models/Pieces/Piece_Base.fbx: 所有棋子共享的唯一基础低模。
        
    - Textures/Pieces/{SkinName}/: 按皮肤名称组织贴图。
        
        - Wood/: 木质皮肤贴图文件夹。
            
        - Jade/: (未来) 玉石皮肤贴图文件夹。
            
- **Assets/Resources/**: **仅存放**需要通过代码 Resources.Load() 动态加载的资源。
    
    - Materials/Pieces/{SkinName}/: 按皮肤名称组织棋子材质。
        
        - Wood/M_Piece_Wood_Red.mat: 示例材质。
            

### **A.2 文件命名规范**

严格的命名规范是自动化处理和代码可读性的基础。

- **模型**:
    
    - Piece_Base.fbx: 棋子基础模型。
        
- **贴图**: Skin_{皮肤名}_{贴图类型}_Set_{颜色}.png
    
    - **Skin_**: 固定前缀。
        
    - **{皮肤名}**: Wood, Jade, Metal 等。
        
    - **{贴图类型}**: Albedo, Normal, Roughness, Metallic, AO 等PBR标准名称。
        
    - **_Set_**: 表示这是一个包含多个棋子的图集。
        
    - **{颜色}**: Red, Black, Blue, Purple。对于通用贴图（如Roughness），省略 _Set_{颜色} 部分。
        
    - **示例**: Skin_Wood_Albedo_Set_Red.png
        
- **材质**: M_Piece_{皮肤名}_{颜色}.mat
    
    - **M_**: 固定前缀，代表Material。
        
    - **示例**: M_Piece_Wood_Red.mat
        

### **A.3 FBX 导出标准 (棋子)**

为保证模型在 Unity 中表现一致，所有棋子模型导出时需遵循以下标准：

1. **单位与尺寸**: Blender 中单位设置为米。模型按真实世界尺寸制作。
    
2. **坐标系**: Forward: -Z, Up: Y。
    
3. **原点 (Origin)**: 必须位于模型底部中心。
    
4. **变换 (Transforms)**: 导出前必须应用所有变换 (Ctrl+A -> All Transforms)，确保Scale为1，Rotation为0。
    
5. **UV**: 必须包含正确展开的 UV 坐标 (UV0)。
    
6. **导出内容**: 只导出 Mesh，不包含摄像机、灯光、骨骼等。
    
7. **平滑组**: 以 Face 方式导出平滑信息。
    

### **A.4 Unity 导入设置 (FBX)**

在 Unity 中选中导入的 FBX 文件后，Inspector 面板的 Model 标签页需进行以下设置：

- **Generate Lightmap UVs**: 取消勾选。
    
- **Normals**: 设置为 Import。
    
- **Tangents**: 设置为 Calculate Mikktspace。