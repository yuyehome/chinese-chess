# **《象棋荣耀》技术交接文档 (v2.0)**

## **引言：核心架构理念**

本项目采用了一套现代化、高度解耦的架构，旨在实现以下核心目标：

1. **数据驱动 (Data-Driven)**: 游戏世界的一切都由一个纯数据容器 GameState 来描述。它是“唯一的事实来源 (Single Source of Truth)”。
    
2. **指令模式 (Command Pattern)**: 所有改变游戏状态的操作都必须封装成 ICommand 对象。这使得逻辑可追溯、可回放，并且天然适合网络同步。
    
3. **视图-逻辑分离 (MV Architecture)**: 游戏逻辑（Model）、视觉表现（View）和用户输入（Controller）被严格分离。这保证了代码的低耦合、高可维护性和易测试性。
    

**核心数据流 (网络环境)**: **客户端输入 -> 网络指令(NetworkCommand) -> [网络] -> Host端接收 -> 逻辑指令(ICommand) -> 处理器(Processor) -> 权威状态(GameState) -> [网络RPC] -> 客户端接收 -> 状态应用 -> 表现(View)**

---

## **第一部分：文件夹结构总览**

codeCode

```
Assets/
├── Scenes/               # 存放所有场景文件 (e.g., BattleScene, MainMenuScene)
├── Scripts/              # 存放所有C#脚本
│   ├── _Core/            # 游戏核心框架 (与具体游戏玩法、UI表现无关)
│   │   ├── Foundation/   # 最底层的工具类 (单例、常量等)
│   │   ├── Data/         # 纯数据结构定义 (棋子、玩家信息等)
│   │   ├── GameState/    # GameState 容器的定义
│   │   ├── Command/      # 指令接口、具体指令类及指令处理器
│   │   ├── GameModes/    # 可插拔的游戏模式规则逻辑
│   │   ├── Networking/   # 网络抽象层与具体实现
│   │   ├── Controller/   # 负责处理输入、驱动游戏循环的控制器
│   │   └── View/         # 负责将GameState渲染到屏幕上的视图类
│   ├── _Gameplay/        # 核心玩法层 (后续开发，如技能具体实现、AI逻辑)
│   └── _App/             # 应用与表现层 (UI管理器、场景加载、游戏总管等)
│       └── GameManagement/ # 游戏整体生命周期管理
├── Art/                  # 所有美术资源
├── Audio/                # 所有音频资源
├── Prefabs/              # 预制体 (e.g., PiecePrefab, NetworkEvents)
└── _Content/             # 存放 ScriptableObject 策划配置文件
    └── GameConfig/
```

---

## **第二部分：核心脚本文件索引**

|   |   |   |
|---|---|---|
|文件路径|脚本名称|核心职责|
|**_Core/Foundation/**|Singleton<T>.cs|线程安全的MonoBehaviour单例基类。|
||PersistentSingleton<T>.cs|跨场景不销毁的单例基类。|
|**_Core/Data/**|DataEnums.cs|定义核心枚举，如PlayerTeam, PieceType, PieceStatus。|
||GameData.cs|定义核心纯数据结构，如PieceData, PlayerProfile。|
|**_Core/GameState/**|GameState.cs|游戏世界唯一数据快照，包含所有棋子、玩家数据。|
|**_Core/Command/**|ICommand.cs|所有逻辑指令的接口，定义了Execute方法。|
||MoveCommand.cs|封装“移动棋子”操作的具体逻辑指令。|
||CommandProcessor.cs|**逻辑心脏**。在Host端接收、验证、执行指令，并更新权威GameState。|
|**_Core/GameModes/**|IGameModeLogic.cs|游戏模式规则的接口，用于指令验证和游戏进程推进。|
||GameModeManager.cs|工厂类，用于根据游戏模式创建对应的规则实例。|
|**_Core/Networking/**|INetworkService.cs|**网络层抽象接口**。解耦游戏逻辑与具体网络框架(Mirror)。|
||MirrorService.cs|INetworkService的Mirror实现，管理网络连接与消息收发。|
||NetworkData.cs|定义用于网络传输的数据结构，如NetworkCommand。|
||NetworkEvents.cs|**网络事件中心**。一个网络对象，负责将Host的状态变更以RPC形式广播给客户端。|
||NetworkServiceProvider.cs|服务定位器，为上层逻辑提供INetworkService的全局唯一实例。|
||NetworkSerializers.cs|为自定义数据类型(如PieceData)提供Mirror所需的序列化和反序列化方法。|
||NetworkPlayer.cs|代表每个网络连接的玩家对象，用于触发新玩家加入时的状态同步流程。|
|**_Core/View/**|PieceView.cs|单个棋子在3D场景中的视觉表现。|
||BoardView.cs|棋盘总视图，根据GameState的变更创建、更新、销毁PieceView。|
|**_Core/Controller/**|InputController.cs|(客户端)监听玩家输入，将其转换为NetworkCommand并通过网络服务发送。|
|**_App/GameManagement/**|GameLoopController.cs|**游戏粘合剂**。初始化各核心系统，作为Host权威逻辑与客户端表现的中央协调者。|

---

## **第三部分：核心模块详解**

### **3.1 基础层 (_Core/Foundation & _Core/Data)**

- **设计目标**: 提供全项目通用的数据结构和工具。
    
- **核心理念**:
    
    - 数据结构（PieceData, PlayerProfile等）是纯C#类/结构体，不依赖Unity，便于序列化和网络传输。
        
    - 为需要在网络间传输的自定义结构体（如PieceData），在 NetworkSerializers.cs 中提供对应的序列化扩展方法。
        

### **3.2 核心循环 (_Core/GameState & _Core/Command)**

- **设计目标**: 建立一个**仅在Host端运行**的、确定性的、可追溯的游戏逻辑处理核心。
    
- **核心理念**:
    
    - Host端的 GameState 是唯一权威的数据源。所有逻辑计算和裁决都必须基于它。
        
    - CommandProcessor 是唯一的逻辑执行者，**任何对权威GameState的修改都必须通过它在Host端完成**。
        
    - 客户端拥有一个 GameState 的本地镜像，该镜像**只能**通过接收来自Host的网络事件(RPC)来更新。
        

### **3.3 网络层 (_Core/Networking)**

- **设计目标**: 构建一个健壮、高效、可扩展的网络层，采用权威服务器模型。
    
- **核心理念**:
    
    - **网络抽象 (INetworkService)**: 上层逻辑（如InputController）通过此接口与网络交互，无需关心底层是Mirror还是未来的其他框架。
        
    - **指令驱动 (NetworkCommand)**: 客户端将操作意图封装成纯数据的NetworkCommand发送给Host，而非直接尝试修改状态。
        
    - **事件同步 (NetworkEvents)**: Host在权威逻辑处理完毕后，不直接同步整个GameState，而是将原子化的“状态变更事件”（如棋子移动、棋子死亡）通过NetworkEvents对象的RPC广播给所有客户端。
        
- **关键组件**:
    
    - MirrorService: 继承自Mirror的NetworkManager，是网络功能的具体实现者。
        
    - NetworkPlayer: 每个连接客户端时，Host会为其生成一个NetworkPlayer实例。该实例的OnStartServer是触发对新客户端进行“初始全盘状态同步”的最佳时机。
        
    - NetworkEvents: 这是一个在场景中唯一的、被NetworkServer.Spawn的网络对象。Host通过调用它的[ClientRpc]方法来广播事件，客户端通过接收这些RPC来更新自己的游戏世界。
        

### **3.4 规则与表现分离 (_Core/GameModes, _Core/Controller, _Core/View)**

- **设计目标**: 将游戏规则、玩家输入和视觉表现彻底解耦，使其在网络环境中清晰工作。
    
- **核心理念**:
    
    - **InputController (输入层)**: **仅在客户端**工作。职责是“翻译”，将玩家的原始输入（点击）翻译成NetworkCommand，然后通过INetworkService发送出去。
        
    - **GameLoopController (粘合层)**:
        
        - **在Host端**，它初始化CommandProcessor，监听其C#事件（如OnPieceUpdated），并将这些事件**翻译**成NetworkEvents的RPC调用。同时，它也直接更新Host本地的BoardView。
            
        - **在Client端**，它提供一系列Handle...FromNet方法，这些方法被NetworkEvents的RPC所调用，用于接收网络事件并更新本地的GameState和BoardView。
            
    - **View (表现层)**: 其职责是“渲染”。它被GameLoopController驱动，忠实地将本地GameState的状态呈现出来。
        

### **3.5 核心工作流 (一个完整的网络移动操作)**

1. **客户端 - 输入**: 玩家点击棋子和目标点。InputController捕获输入，创建一个填充了pieceId和targetPosition的NetworkCommand。
    
2. **客户端 - 发送**: InputController调用NetworkServiceProvider.Instance.SendCommandToServer(cmd)。客户端的MirrorService将此NetworkCommand通过网络发送给Host。
    
3. **Host端 - 接收与解析**: Host端的MirrorService在OnServerReceiveCommand中收到NetworkCommand。它将这个网络数据结构**反向解析**为一个逻辑层的ICommand实例（例如 new MoveCommand(...)）。
    
4. **Host端 - 权威处理**: MirrorService调用GameLoopController.RequestProcessCommand(logicCmd)。GameLoopController确认自己是权威(Host)，将指令交给CommandProcessor。
    
5. **Host端 - 状态变更与本地更新**: CommandProcessor通过IGameModeLogic验证指令（如行动点），验证通过后执行指令，修改**权威GameState**。这会触发CommandProcessor的C#事件（如OnPieceUpdated）。
    
6. **Host端 - 广播与本地视图更新**: GameLoopController的事件处理器HandlePieceUpdated被调用。它会做两件事：  
    a. **立即更新本地视图**: 调用boardView.OnPieceUpdated()，使Host玩家能立刻看到移动效果。  
    b. **广播给客户端**: 调用NetworkEvents.Instance.RpcOnPieceUpdated()，将PieceData通过RPC广播给所有其他客户端。
    
7. **客户端 - 接收与应用**: 其他客户端的NetworkEvents实例接收到RpcOnPieceUpdated调用。
    
8. **客户端 - 状态与视图更新**: NetworkEvents调用GameLoopController.HandlePieceUpdated_FromNet()。该方法更新客户端的**本地GameState镜像**，并调用boardView.OnPieceUpdated()来驱动PieceView播放移动动画。
    

---