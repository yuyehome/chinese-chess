# **《象棋荣耀》技术交接文档 (v2.0)**

## **引言：核心架构理念**

本项目采用了一套现代化、高度解耦的架构，旨在实现以下核心目标：

1. **数据驱动 (Data-Driven)**: 游戏世界的一切都由一个纯数据容器 GameState 来描述。它是“唯一的事实来源 (Single Source of Truth)”。
    
2. **指令模式 (Command Pattern)**: 所有改变游戏状态的操作都必须封装成 ICommand 对象。这使得逻辑可追溯、可回放，并且天然适合网络同步。
    
3. **视图-逻辑分离 (MV Architecture)**: 游戏逻辑（Model）、视觉表现（View）和用户输入（Controller）被严格分离。这保证了代码的低耦合、高可维护性和易测试性。
    

**核心数据流 (网络环境)**: **客户端输入 -> 网络指令(NetworkCommand) -> [网络] -> Host端接收 -> 逻辑指令(ICommand) -> 处理器(Processor) -> 权威状态(GameState) -> [网络RPC] -> 客户端接收 -> 状态应用 -> 表现(View)**

---

## **第一部分：文件夹结构总览**


Assets/
├── Scenes/               # 存放所有场景文件 (e.g., BattleScene, MainMenuScene)
├── Scripts/              # 存放所有C#脚本
│   ├── _Core/            # 游戏核心框架 (与具体游戏玩法、UI表现无关)
│   │   ├── Foundation/   # 最底层的工具类 (单例、常量等)
│   │   ├── Data/         # 纯数据结构定义 (棋子、玩家信息等)
│   │   ├── GameState/    # GameState 容器的定义
│   │   ├── Command/      # 指令接口、具体指令类及指令处理器
│   │   ├── GameModes/    # 可插拔的游戏模式规则逻辑
│   │   ├── Networking/   # 网络抽象层与具体实现
│   │   ├── Audio/        # 音效管理系统
│   │   ├── Localization/ # 国际化系统
│   │   ├── Controller/   # 负责处理输入、驱动游戏循环的控制器
│   │   └── View/         # 负责将GameState渲染到屏幕上的视图类
│   ├── _Gameplay/        # 核心玩法层 (后续开发，如技能具体实现、AI逻辑)
│   │   ├── Rules/            # 纯粹的、无状态的游戏规则计算库
│   │   └── TurnBased/        # 回合制模式的特有逻辑
│   └── _App/             # 应用与表现层 (UI管理器、场景加载、游戏总管等)
│       └── GameManagement/ # 游戏整体生命周期管理
├── Resources/                #  存放所有需要通过 Resources.Load 动态加载的资源
│   ├── Materials/            # 材质，按皮肤和类型组织
│   │   └── Pieces/
│   │       └── Wood/
│   └── ... (其他未来可能需要动态加载的资源)
├── Art/                  # 所有美术资源
│   ├── Models/
│   └── Textures/
├── Audio/                # 所有音频资源
├── Prefabs/              # 预制体 (e.g., PiecePrefab, NetworkEvents)
└── _Content/             # 存放 ScriptableObject 策划配置文件
    ├── GameConfig/       # 游戏玩法数值配置 (e.g., HeroConfig, SkillConfig)
    ├── Audio/            # 音频数据配置 (e.g., GameAudioData)
    └── Localization/     # 国际化数据配置 (e.g., Language_Text_ZH_CN)


---

## **第二部分：核心脚本文件索引**


|                          |                           |                                                |
| ------------------------ | ------------------------- | ---------------------------------------------- |
| 文件路径                     | 脚本名称                      | 核心职责                                           |
| **_Core/Foundation/**    | Singleton.cs              | 线程安全的MonoBehaviour单例基类。                        |
|                          | PersistentSingleton.cs    | 跨场景不销毁的单例基类。                                   |
|                          | GameConstants.cs          |                                                |
| **_Core/Data/**          | DataEnums.cs              | 定义核心枚举，如PlayerTeam, PieceType, PieceStatus。    |
|                          | GameData.cs               | 定义核心纯数据结构，如PieceData, PlayerProfile。           |
| **_Core/GameState/**     | GameState.cs              | 游戏世界唯一数据快照，包含所有棋子、玩家数据。                        |
| **_Core/Command/**       | ICommand.cs               | 所有逻辑指令的接口，定义了Execute方法。                        |
|                          | MoveCommand.cs            | 封装“移动棋子”操作的具体逻辑指令。                             |
|                          | RequestDrawCommand.cs     | 封装“请求和棋”操作的具体逻辑指令。                             |
|                          | AcceptDrawCommand.cs      | 封装“接受和棋”操作的具体逻辑指令。                             |
|                          | EndTurnCommand.cs         | 封装“回合结束”操作的具体逻辑指令。                             |
|                          | UseSkillCommand.cs        | TODO                                           |
|                          | ResignCommand.cs          | 封装“投降”操作的具体逻辑指令。                               |
|                          | CommandProcessor.cs       | 逻辑心脏。在Host端接收、验证、执行指令，并更新权威GameState。          |
| **_Core/GameModes/**     | IGameModeLogic.cs         | 游戏模式规则的接口，用于指令验证和游戏进程推进。                       |
|                          | GameModeManager.cs        | 工厂类，用于根据游戏模式创建对应的规则实例。                         |
|                          | GameModeType.cs           |                                                |
|                          | RealTimeLogic.cs          | TODO                                           |
| **_Core/Networking/**    | INetworkService.cs        | 网络层抽象接口。解耦游戏逻辑与具体网络框架(Mirror)。                 |
|                          | MirrorService.cs          | INetworkService的Mirror实现，管理网络连接与消息收发。          |
|                          | OfflineService.cs         | INetworkService的单机实现，用于无网络环境的开发与测试。            |
|                          | NetworkData.cs            | 定义用于网络传输的数据结构，如NetworkCommand。                 |
|                          | NetworkEvents.cs          | 网络事件中心。一个网络对象，负责将Host的状态变更以RPC形式广播给客户端。        |
|                          | NetworkSerializers.cs     |                                                |
|                          | NetworkServiceProvider.cs | 服务定位器，为上层逻辑提供INetworkService的全局唯一实例。           |
| **_Core/Audio/**         | AudioData.cs              | (ScriptableObject) 定义音频Key与AudioClip的映射关系。     |
|                          | AudioManager.cs           | 音效服务。管理BGM和SFX的播放，提供全局音量控制和音效池。                |
| **_Core/Localization/**  | LocalizationData.cs       | (ScriptableObject) 定义国际化Key与文本/资源(Asset)的映射关系。 |
|                          | LocalizationManager.cs    | 国际化服务。管理语言切换，提供获取本地化文本和资源的接口。                  |
|                          | LocalizedText.cs          | (UI组件) 挂载到Text/TextMeshProUGUI上，使其文本根据Key自动更新。 |
|                          | LocalizedImage.cs         | (UI组件) 挂载到Image上，使其Sprite根据Key自动更新。            |
| **_Core/View/**          | PieceView.cs              | 单个棋子在3D场景中的视觉表现。                               |
|                          | BoardView.cs              | 棋盘总视图，根据GameState的变更创建、更新、销毁PieceView。         |
|                          | BoardGridRenderer.cs      | 视觉表现。负责程序化地绘制棋盘网格线及开局动画。                       |
| **_Core/Controller/**    | InputController.cs        | (客户端)监听玩家输入，将其转换为NetworkCommand并通过网络服务发送。      |
| **_Gameplay/Rules/**     | PieceMovementGenerator.cs | 规则库。一个纯静态类，用于计算各种棋子在理论上的所有移动可能性。               |
| **_App/GameManagement/** | GameLoopController.cs     | 游戏粘合剂。初始化各核心系统，作为Host权威逻辑与客户端表现的中央协调者。         |
|                          | SkinManager.cs            | 皮肤服务。管理所有棋子皮肤材质的加载、缓存和供应。                      |
| **_Content/GameConfig/** | BoardConfig.cs            | (ScriptableObject) 定义棋盘的物理尺寸、格子间距和坐标转换方法。      |
|                          | PieceSkinData.cs          | (ScriptableObject) 定义棋子皮肤图集的UV分割数据。            |
|                          | GameBalanceConfig.cs      |                                                |
|                          | HeroConfig.cs             | TODO                                           |
|                          | SkillConfig.cs            | TODO                                           |


---

## **第三部分：核心模块详解**

### **3.1 基础层 (_Core/Foundation & _Core/Data)**

- **设计目标**: 提供全项目通用的数据结构和工具。
    
- **核心理念**:
    
    - 数据结构（PieceData, PlayerProfile等）是纯C#类/结构体，不依赖Unity，便于序列化和网络传输。
        
    - 为需要在网络间传输的自定义结构体（如PieceData），在 NetworkSerializers.cs 中提供对应的序列化扩展方法。
        

### **3.2 核心循环 (_Core/GameState & _Core/Command)**

- **设计目标**: 建立一个**仅在Host端运行**的、确定性的、可追溯的游戏逻辑处理核心。
    
- **核心理念**:
    
    - Host端的 GameState 是唯一权威的数据源。所有逻辑计算和裁决都必须基于它。
        
    - CommandProcessor 是唯一的逻辑执行者，**任何对权威GameState的修改都必须通过它在Host端完成**。
        
    - 客户端拥有一个 GameState 的本地镜像，该镜像**只能**通过接收来自Host的网络事件(RPC)来更新。
        

### **3.3 网络层 (_Core/Networking)**

- **设计目标**: 构建一个健壮、高效、可扩展的网络层，采用权威服务器模型。
    
- **核心理念**:
    
    - **网络抽象 (INetworkService)**: 上层逻辑（如InputController）通过此接口与网络交互，无需关心底层是Mirror还是未来的其他框架。
        
    - **指令驱动 (NetworkCommand)**: 客户端将操作意图封装成纯数据的NetworkCommand发送给Host，而非直接尝试修改状态。
        
    - **事件同步 (NetworkEvents)**: Host在权威逻辑处理完毕后，不直接同步整个GameState，而是将原子化的“状态变更事件”（如棋子移动、棋子死亡）通过NetworkEvents对象的RPC广播给所有客户端。
        
- **关键组件**:
    
    - MirrorService: 继承自Mirror的NetworkManager，是网络功能的具体实现者。
        
    - NetworkPlayer: 每个连接客户端时，Host会为其生成一个NetworkPlayer实例。该实例的OnStartServer是触发对新客户端进行“初始全盘状态同步”的最佳时机。
        
    - NetworkEvents: 这是一个在场景中唯一的、被NetworkServer.Spawn的网络对象。Host通过调用它的[ClientRpc]方法来广播事件，客户端通过接收这些RPC来更新自己的游戏世界。
        

### **3.4 规则与表现分离 (_Core/GameModes, _Core/Controller, _Core/View)**

- **设计目标**: 将游戏规则、玩家输入和视觉表现彻底解耦，使其在网络环境中清晰工作。
    
- **核心理念**:
    
    - **InputController (输入层)**: **仅在客户端**工作。职责是“翻译”，将玩家的原始输入（点击）翻译成NetworkCommand，然后通过INetworkService发送出去。
        
    - **GameLoopController (粘合层)**:
        
        - **在Host端**，它初始化CommandProcessor，监听其C#事件（如OnPieceUpdated），并将这些事件**翻译**成NetworkEvents的RPC调用。同时，它也直接更新Host本地的BoardView。
            
        - **在Client端**，它提供一系列Handle...FromNet方法，这些方法被NetworkEvents的RPC所调用，用于接收网络事件并更新本地的GameState和BoardView。
            
    - **View (表现层)**: 其职责是“渲染”。它被GameLoopController驱动，忠实地将本地GameState的状态呈现出来。
        

### **3.5 核心工作流 (一个完整的网络移动操作)**

1. **客户端 - 输入**: 玩家点击棋子和目标点。InputController捕获输入，创建一个填充了pieceId和targetPosition的NetworkCommand。
    
2. **客户端 - 发送**: InputController调用NetworkServiceProvider.Instance.SendCommandToServer(cmd)。客户端的MirrorService将此NetworkCommand通过网络发送给Host。
    
3. **Host端 - 接收与解析**: Host端的MirrorService在OnServerReceiveCommand中收到NetworkCommand。它将这个网络数据结构**反向解析**为一个逻辑层的ICommand实例（例如 new MoveCommand(...)）。
    
4. **Host端 - 权威处理**: MirrorService调用GameLoopController.RequestProcessCommand(logicCmd)。GameLoopController确认自己是权威(Host)，将指令交给CommandProcessor。
    
5. **Host端 - 状态变更与本地更新**: CommandProcessor通过IGameModeLogic验证指令（如行动点），验证通过后执行指令，修改**权威GameState**。这会触发CommandProcessor的C#事件（如OnPieceUpdated）。
    
6. **Host端 - 广播与本地视图更新**: GameLoopController的事件处理器HandlePieceUpdated被调用。它会做两件事：  
    a. **立即更新本地视图**: 调用boardView.OnPieceUpdated()，使Host玩家能立刻看到移动效果。  
    b. **广播给客户端**: 调用NetworkEvents.Instance.RpcOnPieceUpdated()，将PieceData通过RPC广播给所有其他客户端。
    
7. **客户端 - 接收与应用**: 其他客户端的NetworkEvents实例接收到RpcOnPieceUpdated调用。
    
8. **客户端 - 状态与视图更新**: NetworkEvents调用GameLoopController.HandlePieceUpdated_FromNet()。该方法更新客户端的**本地GameState镜像**，并调用boardView.OnPieceUpdated()来驱动PieceView播放移动动画。
    
### **3.6 音效系统 (_Core/Audio)**

- **设计目标**: 提供一个中心化的服务来管理和播放所有背景音乐(BGM)和音效(SFX)。
    
- **核心理念**:
    
    - **数据驱动 (AudioData.cs)**: 使用ScriptableObject将音效的**唯一标识Key**(如 "sfx_piece_move")与具体的AudioClip文件进行解耦。音效师和策划可以在不修改代码的情况下增删和替换游戏音效。
        
    - **中心化服务 (AudioManager.cs)**: 作为PersistentSingleton存在，提供全局唯一的音效播放入口。它内部管理着一个专门用于循环播放BGM的AudioSource和一个用于高频播放SFX的AudioSource对象池，以优化性能。
        
    - **专业混音 (Audio Mixer)**: AudioManager不直接控制音量，而是通过设置Unity的Audio Mixer中暴露的参数（如 "BGMVolume"）来控制。这使得音量管理和未来添加全局音效（如混响）变得简单。
        
- **工作流 (播放一个棋子移动音效)**:
    
    1. 在_Content/Audio/目录下，策划在AudioData配置文件中添加一个条目，Key为"sfx_piece_move"，并将对应的音效文件拖入。
        
    2. 游戏启动时，AudioManager加载所有AudioData，将Key-Clip映射缓存到字典中。
        
    3. 在PieceView.cs中，当棋子开始移动时，代码调用 AudioManager.Instance.PlaySFX("sfx_piece_move");。
        
    4. AudioManager根据Key找到对应的AudioClip，从对象池中取出一个空闲的AudioSource，调用PlayOneShot()播放音效。
        

### **3.7 国际化系统 (_Core/Localization)**

- **设计目标**: 使游戏内的所有文本和部分资源能够根据当前选择的语言自动切换。
    
- **核心理念**:
    
    - **数据驱动 (LocalizationData.cs)**: 为**每种语言**创建一个ScriptableObject数据文件（如Language_Text_ZH_CN.asset）。该文件存储了该语言环境下所有文本/资源的Key-Value映射。这使得添加新语言或修改翻译无需重编译代码。
        
    - **中心化服务 (LocalizationManager.cs)**: PersistentSingleton单例，负责加载所有语言的数据，管理当前语言的切换，并提供GetText(key)和GetAsset<T>(key)等核心接口。

	- **自动化UI组件 (LocalizedText.cs, LocalizedImage.cs)**: 这些辅助组件可以直接挂载到Unity的UI元素上。开发者只需在Inspector中为其指定一个localizationKey，这些组件就会自动订阅LocalizationManager的语言切换事件，并在语言变化时自动刷新显示内容。
        
- **工作流 (更新一个UI按钮的文本)**:
    
    1. 在_Content/Localization/目录下，翻译人员在Language_Text_ZH_CN.asset中添加条目 {Key: "confirm_button", Value: "确认"}，在Language_Text_EN_US.asset中添加 {Key: "confirm_button", Value: "Confirm"}。
        
    2. UI开发者将LocalizedText组件挂载到按钮的Text组件旁边，并在localizationKey字段填入"confirm_button"。
        
    3. 游戏运行时，LocalizedText组件会自动调用LocalizationManager.Instance.GetText("confirm_button")来设置文本。
        
    4. 当玩家在设置菜单中切换语言，触发LocalizationManager.Instance.SetLanguage()时，OnLanguageChanged事件被广播，所有LocalizedText组件收到事件后，会再次获取文本并刷新，UI界面瞬间完成语言切换。


### **3.8 皮肤系统 (_App/GameManagement/SkinManager & _Core/View/PieceView)**

- **设计目标**: 实现一个高效、可扩展的棋子皮肤系统，允许在不更换模型的情况下，通过更换材质和修改UV来改变棋子外观。
    
- **核心理念**:
    
    - **单一模型，多种外观**: 所有棋子共享同一个基础模型 (Piece_Base.fbx)，极大优化了性能和资源管理。
        
    - **数据驱动 (PieceSkinData.cs)**: 棋子图集的UV分割信息存储在 ScriptableObject 中，策划可配置，代码只负责读取和应用。
        
    - **中心化服务 (SkinManager.cs)**: 作为 PersistentSingleton，在游戏启动时预加载所有皮肤材质，为 PieceView 提供一个统一、高效的材质获取接口。材质按 SkinType 和 PlayerTeam 进行索引。
        
    - **视图自治 (PieceView.cs)**: 每个 PieceView 实例在被初始化时，会主动向 SkinManager 请求自己所需的材质，并根据 PieceSkinData 修改自身Mesh的UV坐标，完成“换肤”。为了不影响项目源文件，PieceView 会在内存中创建其Mesh的一个实例(_instancedMesh)进行操作。
        
- **工作流 (创建一个红色木纹“车”)**:
    
    1. GameLoopController 通知 BoardView 创建棋子。
        
    2. BoardView 实例化一个 Piece_Template.prefab，并调用其 PieceView 组件的 Initialize(pieceData) 方法。
        
    3. PieceView.Initialize 被调用，pieceData 中包含 { team: Red, type: Chariot }。
        
    4. PieceView 调用 SkinManager.Instance.GetPieceMaterial(SkinType.Wood, PlayerTeam.Red)，获得一个红色的木纹材质**实例**。
        
    5. PieceView 将此材质应用到自己的 MeshRenderer。
        
    6. PieceView 从其引用的 PieceSkinData 中，调用 GetUVRect(PieceType.Chariot)，获得“车”在图集中的UV区域 Rect。
        
    7. PieceView 创建自己Mesh的实例，并根据获取的 Rect 重新计算所有UV坐标，应用到实例化的Mesh上。棋子正确显示。
        

### **3.9 坐标系统 (_Content/GameConfig/BoardConfig)**

- **设计目标**: 将游戏的逻辑坐标（格子坐标，如 (0,0)）与场景中的物理坐标（世界坐标，如 (0.05, 0, 0.1)）完全解耦。
    
- **核心理念**:
    
    - **单一事实来源 (BoardConfig.cs)**: 所有关于棋盘物理尺寸的“真理”都存储在这个 ScriptableObject 中，包括格子间距(gridSpacing)、原点偏移(originOffset)等。
        
    - **中心化转换**: BoardConfig 提供了 GridToWorld() 和 WorldToGrid() 两个核心转换方法。所有需要进行坐标转换的脚本（如 BoardView, InputController）都必须通过它来完成，确保了全项目坐标系的高度统一。
        
    - **视图层持有**: BoardView 作为棋盘视觉表现的总管，持有对 BoardConfig 的引用，并可将其提供给其他需要坐标转换服务的脚本。


---

## **附录 A：美术资源管线规范 (v1.0)**

### **A.1 文件夹结构**

为确保资源的可查找性和代码引用的稳定性，所有美术资源必须遵循以下目录结构：

- **Assets/Art/**: 存放所有美术**源文件**，如 .blend, .psd, .spp 等，以及不需要被代码动态加载的模型和贴图文件。
    
    - Models/Pieces/Piece_Base.fbx: 所有棋子共享的唯一基础低模。
        
    - Textures/Pieces/{SkinName}/: 按皮肤名称组织贴图。
        
        - Wood/: 木质皮肤贴图文件夹。
            
        - Jade/: (未来) 玉石皮肤贴图文件夹。
            
- **Assets/Resources/**: **仅存放**需要通过代码 Resources.Load() 动态加载的资源。
    
    - Materials/Pieces/{SkinName}/: 按皮肤名称组织棋子材质。
        
        - Wood/M_Piece_Wood_Red.mat: 示例材质。
            

### **A.2 文件命名规范**

严格的命名规范是自动化处理和代码可读性的基础。

- **模型**:
    
    - Piece_Base.fbx: 棋子基础模型。
        
- **贴图**: Skin_{皮肤名}_{贴图类型}_Set_{颜色}.png
    
    - **Skin_**: 固定前缀。
        
    - **{皮肤名}**: Wood, Jade, Metal 等。
        
    - **{贴图类型}**: Albedo, Normal, Roughness, Metallic, AO 等PBR标准名称。
        
    - **_Set_**: 表示这是一个包含多个棋子的图集。
        
    - **{颜色}**: Red, Black, Blue, Purple。对于通用贴图（如Roughness），省略 _Set_{颜色} 部分。
        
    - **示例**: Skin_Wood_Albedo_Set_Red.png
        
- **材质**: M_Piece_{皮肤名}_{颜色}.mat
    
    - **M_**: 固定前缀，代表Material。
        
    - **示例**: M_Piece_Wood_Red.mat
        

### **A.3 FBX 导出标准 (棋子)**

为保证模型在 Unity 中表现一致，所有棋子模型导出时需遵循以下标准：

1. **单位与尺寸**: Blender 中单位设置为米。模型按真实世界尺寸制作。
    
2. **坐标系**: Forward: -Z, Up: Y。
    
3. **原点 (Origin)**: 必须位于模型底部中心。
    
4. **变换 (Transforms)**: 导出前必须应用所有变换 (Ctrl+A -> All Transforms)，确保Scale为1，Rotation为0。
    
5. **UV**: 必须包含正确展开的 UV 坐标 (UV0)。
    
6. **导出内容**: 只导出 Mesh，不包含摄像机、灯光、骨骼等。
    
7. **平滑组**: 以 Face 方式导出平滑信息。
    

### **A.4 Unity 导入设置 (FBX)**

在 Unity 中选中导入的 FBX 文件后，Inspector 面板的 Model 标签页需进行以下设置：

- **Generate Lightmap UVs**: 取消勾选。
    
- **Normals**: 设置为 Import。
    
- **Tangents**: 设置为 Calculate Mikktspace。