### **详细设计文档: B-4.1 - 基础AI实现**

**文档版本**: 1.0  
**设计目标**: 构建一个分层、模块化、可扩展的AI系统。该系统需能支持回合制和实时制两种模式，并通过配置轻松实现不同难度和行为风格，为游戏提供有挑战性且行为多样的PVE体验。

---

### **第一部分：核心功能与逻辑说明 (Functional & Logic Specification)**

本AI系统遵循“**感知(Perception) -> 思考(Thinking) -> 行动(Action)**”的设计哲学。

1. **感知 (Perception - The Blackboard)**
    
    - AI不直接读取原始的GameState。在每次决策前，一个“信息处理器”会分析GameState，提取出高级战术信息（如：每个棋子的威胁值、最佳攻击目标、安全位置等），并存入一个名为“黑板”(AIBlackboard)的临时数据容器中。这为AI的“思考”提供了清晰、聚焦的数据输入。
        
2. **思考 (Thinking - The Brain)**
    
    - AI的决策核心，即“大脑”，会根据“黑板”上的信息做出决策。
        
    - **回合制 (M1)**: 大脑是一个基于**Alpha-Beta剪枝算法**的搜索引擎。它通过搜索未来的几种可能性，并使用一个**局面评估函数**来给不同的棋局打分，从而找到对自己最有利的走法。AI的难度由搜索的深度决定。
        
    - **实时制 (M2, M3)**: 大脑是一个**行为树 (Behavior Tree)**。它通过一系列的“如果...那么...”逻辑判断，来决定当前最优先应该执行的行为，如“保命”、“抓住机会”、“积攒资源”等。AI的难度和风格由行为树的结构、参数（如反应延迟）决定。
        
3. **行动 (Action - The Command)**
    
    - AI“思考”的最终产物是一个具体的行动意图（如“用5号车移动到X,Y点”）。
        
    - 这个意图会被翻译成一个标准的ICommand对象（如MoveCommand），然后通过与玩家完全相同的路径（INetworkService.SendCommand）提交给游戏逻辑核心，确保AI的行为与玩家行为在规则层面完全一致，保证公平性。
        

---

### **第二部分：技术架构与代码设计 (Technical & Code Design)**

### **模块 1: Gameplay.AI.Core - AI核心框架**

#### **1.1. 模块目标 (Goal)**

搭建AI系统的通用框架，包括AI控制器、黑板系统以及与游戏主循环的接口。

#### **1.2. 模块内容与技术方案**

- **代码路径**: Assets/Script/_Gameplay/AI/Core/
    
- **类设计**:
    
    1. **AIController**
        
        - **类型**: class (非MonoBehaviour)
            
        - **职责**: 单个AI玩家的总控制器。负责在合适的时机（如轮到AI行动或固定的时间间隔）触发决策流程。
            
        - **关键成员**:
            
            - private readonly PlayerTeam team;
                
            - private readonly IAIBehavior brain; (AI的大脑)
                
            - private readonly AIBlackboard blackboard;
                
            - private readonly AITargetSelector targetSelector;
                
        - **关键方法**:
            
            - public void OnStartTurn(GameState state); (回合制调用)
                
            - public void OnTick(GameState state, float deltaTime); (实时制调用)
                
                1. blackboard.Update(state, team); (感知)
                    
                2. ICommand chosenCommand = brain.Think(blackboard); (思考)
                    
                3. if (chosenCommand != null) { SendCommand(chosenCommand); } (行动)
                    
    2. **IAIBehavior**
        
        - **类型**: 接口
            
        - **职责**: 定义AI“大脑”的通用接口。
            
        - **关键方法**: ICommand Think(AIBlackboard blackboard);
            
    3. **AIBlackboard**
        
        - **类型**: class
            
        - **职责**: AI的短期记忆和战术信息中心。
            
        - **关键成员**:
            
            - public GameState CurrentState { get; private set; }
                
            - public List<PieceData> MyPieces { get; private set; }
                
            - public List<PieceData> EnemyPieces { get; private set; }
                
            - public float MyActionPoints { get; private set; }
                
            - public TacticalInfo MostThreateningEnemy { get; private set; }
                
            - public TacticalInfo BestAttackTarget { get; private set; }
                
        - **关键方法**: public void Update(GameState state, PlayerTeam myTeam); (遍历state，计算并填充以上所有字段)
            

### **模块 2: Gameplay.AI.TurnBased - 回合制AI实现**

#### **2.1. 模块目标 (Goal)**

实现基于Alpha-Beta剪枝算法的回合制AI大脑。

#### **2.2. 模块内容与技术方案**

- **代码路径**: Assets/Script/_Gameplay/AI/TurnBased/
    
- **类设计**:
    
    1. **TurnBasedAIBehavior**
        
        - **类型**: class TurnBasedAIBehavior : IAIBehavior
            
        - **职责**: 实现Alpha-Beta搜索。
            
        - **关键成员**:
            
            - private int searchDepth; (通过构造函数传入，用于控制难度)
                
            - private readonly TurnBasedEvaluator evaluator;
                
        - **ICommand Think(AIBlackboard blackboard)**:
            
            1. 启动Alpha-Beta搜索算法，以blackboard.CurrentState为根节点。
                
            2. 在指定的searchDepth内进行搜索。
                
            3. 搜索过程中，使用evaluator.Evaluate(state)为叶节点打分。
                
            4. 返回得分最高的那个分支所对应的初始MoveCommand。
                
    2. **TurnBasedEvaluator**
        
        - **类型**: class
            
        - **职责**: 实现局面评估函数。
            
        - **关键方法**: public float Evaluate(GameState state, PlayerTeam myTeam);
            
            - **逻辑**:
                
                1. 计算双方棋子总价值分（车=10, 马=5...）。
                    
                2. 计算位置分（兵过河加分，马在中心加分...）。
                    
                3. 计算威胁分（是否有棋子正在攻击对方高价值单位）。
                    
                4. 返回一个总分。
                    

### **模块 3: Gameplay.AI.RealTime - 实时制AI实现**

#### **3.1. 模块目标 (Goal)**

实现基于行为树的实时AI大脑。

#### **3.2. 模块内容与技术方案**

- **代码路径**: Assets/Script/_Gameplay/AI/RealTime/
    
- **技术选型**: 建议使用一个现成的行为树插件（如Unity Asset Store上的 Behavior Designer），因为它提供了强大的可视化编辑器和调试工具。以下设计基于存在这样一个插件的前提。
    
- **类设计**:
    
    1. **RealTimeAIBehavior**
        
        - **类型**: class RealTimeAIBehavior : IAIBehavior
            
        - **职责**: 封装和运行一个行为树实例。
            
        - **关键成员**:
            
            - private BehaviorTree behaviorTree;
                
        - **ICommand Think(AIBlackboard blackboard)**:
            
            1. 将blackboard的数据同步到行为树的内部“黑板”上。
                
            2. 执行behaviorTree.Tick()。
                
            3. 如果行为树在本tick中产出了一个ICommand，则返回它。
                
    2. **自定义行为树节点 (BT Nodes)**
        
        - **职责**: 实现游戏特有的行为和判断逻辑，供策划在可视化编辑器中拖拽使用。
            
        - **路径**: Assets/Script/_Gameplay/AI/RealTime/Nodes/
            
        - **节点示例**:
            
            - **Condition Nodes (返回成功/失败)**:
                
                - IsActionPointsFull: 检查行动点是否已满。
                    
                - CanAttackValuableTarget: 检查blackboard.BestAttackTarget是否存在。
                    
                - IsMyGeneralInDanger: 检查“将”是否受威胁。
                    
            - **Action Nodes (执行动作, 返回成功/失败/运行中)**:
                
                - AttackBestTarget: 创建一个MoveCommand去攻击blackboard.BestAttackTarget。
                    
                - Dodge: 为受威胁的棋子计算一个安全位置并创建MoveCommand。
                    
                - UseSkill_AOE: 查找最佳AOE技能释放时机和位置，创建UseSkillCommand。
                    
                - ExecuteOpeningMove: 执行预设的开局套路。
                    

### **模块 4: Content.AI - AI配置**

#### **4.1. 模块目标 (Goal)**

通过ScriptableObject对AI进行数据驱动的配置，便于策划调整。

#### **4.2. 模块内容与技术方案**

- **代码路径**: Assets/Script/_Content/AI/
    
- **ScriptableObject设计**:
    
    1. **AIProfile**
        
        - **类型**: ScriptableObject
            
        - **职责**: 定义一个完整的AI配置。
            
        - **关键成员**:
            
            - public GameModeType mode; (该配置适用于回合制还是实时制)
                
            - public DifficultyLevel difficulty; (简单/中等/困难)
                
            - public AIStyle style; (进攻型/防守型)
                
            - **回合制配置**:
                
                - public int searchDepth;
                    
                - public TurnBasedEvaluatorConfig evaluatorConfig; (评估函数的权重配置)
                    
            - **实时制配置**:
                
                - public BehaviorTreeAsset behaviorTree; (行为树文件引用)
                    
                - public float reactionTime; (反应延迟)
                    
            - **开局套路**:
                
                - public List<SerializableCommand> openingMoves;
                    

---

### **Unity工作流 (Unity Workflow)**

1. **创建AI配置**:
    
    - 策划在Project窗口右键 -> Create -> ChessHonor -> AI Profile。
        
    - 创建一个“困难-进攻型-实时”AI配置，为其指定一个制作好的“进攻型”行为树文件，并设置较低的反应延迟。
        
    - 创建一个“简单-回合制”AI配置，设置searchDepth = 1。
        
2. **游戏中应用**:
    
    - 当PVE游戏开始时，GameSetupData中会包含一个对AIProfile ScriptableObject的引用。
        
    - GameLoopController读取这个AIProfile。
        
    - 根据profile.mode，创建对应的TurnBasedAIBehavior或RealTimeAIBehavior。
        
    - 将profile中的参数（如searchDepth, behaviorTree）传递给创建的“大脑”实例。
        
    - 最终，将这个“大脑”注入到AIController中。