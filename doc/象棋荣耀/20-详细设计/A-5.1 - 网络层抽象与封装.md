
网络同步相关说明：我们这个游戏，玩家的操作一般只是“把XX棋子从A点移动到B点”，或者“XX棋子在A点使用技能”，而这些操作的“位置点”是基于棋盘的网格。网络同步只需要同步这些指令，host端收到这些指令后，会做逻辑校验，例如行动点是否足够，技能CD有没有好，棋子是否死亡，移动是否合法（是否有障碍）等。host在本地进行后，如果发生了“吃子”或者技能效果等情况，会把命令同步给client端。而不是每帧都要计算位置去同步具体的棋子位置。因为象棋是有棋盘格子的，玩家操作或者技能释放等都是基于棋盘格子，网络请求会非常少。但是棋子在移动的过程中是有一定的速度，慢慢移动过去的，只要同步了这个移动的操作之后，具体哪一帧移动在哪一个精确的位置 这个是不需要同步的。


### **详细设计文档: A-5.1 - 网络层抽象与封装 **

**文档版本**: 2.0  
**设计目标**: 构建一个健壮、高效、可扩展的网络层。该网络层应支持单机与联机模式的无缝切换，采用权威服务器模型保证游戏公平性，并通过事件驱动的RPC实现低带宽占用。同时，该设计将与Steam P2P网络进行深度集成。

---

### **模块 1: Core.Networking - 网络服务核心**

#### **1.1. 核心网络理念与技术选型**

- **网络框架**: **Mirror** (成熟稳定，社区活跃，基于Unity HLAPI)。
    
- **网络拓扑**: **权威服务器 (Host-Server)** 模型。Host玩家同时作为服务端和客户端，运行唯一的权威CommandProcessor。
    
- **状态同步模型**: **事件驱动的RPC同步 (Event-Driven RPC Synchronization)**。Host不直接同步庞大的GameState，而是将逻辑计算后的**原子状态变更事件**（如棋子移动、伤害发生）通过RPC广播给所有客户端。
    
- **指令传输模型**: **指令容器 (Command Container)**。由于Mirror的RPC无法直接传输接口，所有玩家意图将被封装到一个统一的、可序列化的NetworkCommand结构体中进行传输。
    
- **Steam P2P集成**: 使用 **Fizz-Steamworks Transport** 作为Mirror的底层传输层，实现基于Steam好友关系和中继服务器的P2P连接。
    

#### **1.2. 接口设计: INetworkService**

这是上层逻辑（如InputController, GameLoopController）与底层网络框架的唯一交互桥梁，实现了对Mirror的完全解耦。

- **代码路径**: Assets/Script/_Core/Networking/INetworkService.cs
    
- **接口成员**:
    
    - **Events**:
        
        - Action OnConnected: 成功启动Host或连接到Host时触发。
            
        - Action OnDisconnected: 断开连接时触发。
            
        - Action<LobbyState> OnLobbyStateUpdated: (Steam集成) 大厅信息更新时触发。
            
    - **Properties**:
        
        - bool IsHost { get; }: 当前实例是否为Host/Server。
            
        - bool IsClient { get; }: 当前实例是否为客户端。
            
        - bool IsConnected { get; }: 当前是否处于连接状态。
            
    - **Methods**:
        
        - void StartHost(GameSetupData setupData);: 启动Host模式（同时启动Server和Client）。
            
        - void StartClient(string address);: 连接到指定地址的Host。
            
        - void Disconnect();: 断开连接。
            
        - void SendCommandToServer(NetworkCommand command);: **核心方法**。将一个封装好的网络指令发送给Host。
            

#### **1.3. 网络数据结构: NetworkCommand**

用于在网络间传输玩家或AI的意图。

- **代码路径**: Assets/Script/_Core/Networking/NetworkData.cs
    
- **类/结构设计**:
    
    1. **CommandType** (enum): { Move, UseSkill, EndTurn, ... }
        
    2. **NetworkCommand** (struct, 实现Mirror的 NetworkMessage)
        
        - **职责**: 一个通用的、可序列化的指令容器。
            
        - **关键成员**:
            
            - public CommandType type;: 标识指令的类型。
                
            - // --- MoveCommand Fields ---
                
            - public int pieceId;
                
            - public Vector2Int targetPosition;
                
            - public PlayerTeam requestTeam;
                
            - // --- UseSkillCommand Fields ---
                
            - public int casterPieceId;
                
            - public int skillId;
                
            - // ... 其他技能参数 (可以根据需要使用联合体或多个字段)
                

#### **1.4. 实现类 1: MirrorService (在线模式)**

这是INetworkService接口在联机模式下的具体实现，它封装了所有与Mirror API的交互。

- **代码路径**: Assets/Script/_Core/Networking/MirrorService.cs
    
- **类型**: MonoBehaviour, 继承自Mirror的NetworkManager, 并实现INetworkService。
    
- **核心工作流**:
    
    1. **指令发送 (Client -> Host)**:
        
        - InputController调用SendCommandToServer(NetworkCommand cmd)。
            
        - MirrorService内部通过NetworkClient.Send(cmd)将NetworkCommand发送出去。
            
    2. **指令接收与处理 (Host)**:
        
        - Host端的MirrorService注册一个处理器来接收NetworkCommand消息。
            
        - 收到消息后，**将NetworkCommand反向解析为本地的ICommand对象** (如 new MoveCommand(...))。
            
        - 将ICommand对象交给本地的权威CommandProcessor进行处理。
            
    3. **事件广播 (Host -> Clients)**:
        
        - GameLoopController监听CommandProcessor的原子事件（如OnPieceMoved）。
            
        - 当事件触发时，GameLoopController调用MirrorService中对应的RPC方法，例如RpcPieceMoved(pieceId, newPos)。
            
        - MirrorService中的RPC方法使用[ClientRpc]特性，将事件数据广播给所有客户端。
            
    4. **事件接收 (Client)**:
        
        - 客户端的MirrorService实现了RPC方法。
            
        - 当接收到RPC时，它会调用GameLoopController中对应的事件处理器（如HandlePieceMoved），并传入从网络接收到的数据。
            
        - GameLoopController再将这些变更应用到客户端本地的GameState上，最终驱动视图更新。
            

#### **1.5. 实现类 2: OfflineService (单机模式)**

这是一个纯C#类，用于在单机环境下完美模拟MirrorService的行为，实现逻辑代码的复用。

- **代码路径**: Assets/Script/_Core/Networking/OfflineService.cs
    
- **类型**: class, 实现INetworkService。
    
- **核心工作流**:
    
    - StartHost(): 创建本地的GameLoopController和CommandProcessor等。触发OnConnected事件。
        
    - SendCommandToServer(): 不通过网络，而是**直接将NetworkCommand解析为ICommand，并立即喂给本地的CommandProcessor**。
        
    - 内部逻辑: 它直接订阅本地CommandProcessor的原子事件。当事件触发时，它**异步地（例如PostUpdate）**调用GameLoopController的事件处理器，以模拟一个网络帧的延迟，确保数据流与在线模式一致。
        

#### **1.6. 服务定位器: NetworkServiceProvider**

一个简单的静态类或单例，用于根据当前模式（或编辑器开关）提供正确的INetworkService实例。

- **代码路径**: Assets/Script/_Core/Networking/NetworkServiceProvider.cs
    
- **职责**:
    
    - 提供一个静态属性 public static INetworkService Instance { get; }。
        
    - 在游戏启动时，根据配置决定是实例化MirrorService还是OfflineService作为全局唯一的Instance。
        
    - 所有上层代码都通过NetworkServiceProvider.Instance来访问网络功能，而无需关心底层是单机还是联机。
        

---

### **模块 2: Core.Steam - Steam集成与Lobby管理**

此模块负责将游戏房间系统与Steam的社交功能相结合。

#### **2.1. SteamManager**

- **代码路径**: Assets/Script/_Core/Steam/SteamManager.cs
    
- **类型**: PersistentSingleton<SteamManager>
    
- **职责**:
    
    - 初始化和关闭Steamworks.NET。
        
    - 封装常用的Steam API，如获取玩家昵称、头像。
        
    - 处理所有来自Steam的全局回调。
        

#### **2.2. ILobbyService 与 SteamLobbyService**

- **代码路径**: Assets/Script/_Core/Steam/ILobbyService.cs, SteamLobbyService.cs
    
- **职责**: 抽象Steam大厅（Lobby）功能，提供平台无关的房间管理接口。
    
- **ILobbyService接口方法**:
    
    - Task<bool> CreateLobby(LobbySettings settings);: 创建一个大厅。
        
    - void JoinLobby(SteamId lobbyId);: 加入一个大厅。
        
    - void LeaveLobby();: 离开当前大厅。
        
    - Task<Lobby[]> GetLobbyList();: 获取公开的大厅列表。
        
- **SteamLobbyService实现**:
    
    - 将上述接口方法一一映射到Steamworks.NET的ISteamMatchmaking API。
        
    - **与Mirror的联动**:
        
        1. 当CreateLobby成功后，Host调用SteamLobbyService将Lobby的连接地址（即Host自己的Steam ID）设置为Lobby的元数据。
            
        2. 同时，Host启动MirrorService的Host模式（NetworkServiceProvider.Instance.StartHost()）。
            
        3. 当其他玩家JoinLobby成功后，他们从Lobby元数据中读取Host的Steam ID。
            
        4. 然后使用这个Steam ID作为地址，启动MirrorService的Client模式（NetworkServiceProvider.Instance.StartClient(hostSteamId)）。
            

---

### **模块 3: 对现有架构的调整**

#### **3.1. GameLoopController 调整**

- **职责调整**: GameLoopController现在是**网络事件和本地逻辑之间的“翻译官”**。
    
    - **在Host端**: 它监听CommandProcessor的C#事件，并将它们**翻译**成MirrorService的RPC调用。
        
    - **在Client端**: 它提供一系列公共方法（HandlePieceMoved, HandleActionPointsUpdated等），这些方法被MirrorService的RPC实现所调用，用于**接收和应用**网络事件。
        

#### **3.2. InputController 调整**

- **职责调整**: InputController只负责**生成NetworkCommand**。
    
    - 当玩家操作时，它不再创建ICommand接口实例，而是创建一个填充好数据的NetworkCommand结构体。
        
    - 然后通过NetworkServiceProvider.Instance.SendCommandToServer(cmd)将这个结构体发送出去，完成它的使命。