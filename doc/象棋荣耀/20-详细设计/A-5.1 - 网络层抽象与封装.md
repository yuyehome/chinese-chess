### **详细设计文档: A-5.1 - 网络层抽象与封装**

网络同步相关说明：我们这个游戏，玩家的操作一般只是“把XX棋子从A点移动到B点”，或者“XX棋子在A点使用技能”，而这些操作的“位置点”是基于棋盘的网格。网络同步只需要同步这些指令，host端收到这些指令后，会做逻辑校验，例如行动点是否足够，技能CD有没有好，棋子是否死亡，移动是否合法（是否有障碍）等。host在本地进行后，如果发生了“吃子”或者技能效果等情况，会把命令同步给client端。而不是每帧都要计算位置去同步具体的棋子位置。因为象棋是有棋盘格子的，玩家操作或者技能释放等都是基于棋盘格子，网络请求会非常少。但是棋子在移动的过程中是有一定的速度，慢慢移动过去的，只要同步了这个移动的操作之后，具体哪一帧移动在哪一个精确的位置 这个是不需要同步的。



### **3.4 网络层抽象与封装 (_Core/Networking)**

#### **3.4.1 核心网络理念与技术选型**

- **网络框架**: Mirror (基于 Unity 的 HLAPI，成熟稳定，社区活跃)。
    
- **权威模型**: 权威服务器模型 (Host Server)。Host 玩家同时充当客户端和服务端，拥有唯一的 CommandProcessor，负责所有逻辑运算和状态裁决。
    
- **客户端预测 (Client Prediction)**: 客户端发送指令后，立即在本地视觉上执行操作（如棋子移动）。但是吃子等逻辑是由服务端下发指令。这里需要注意的是，例如client是黑方，host是红方。那么黑方本地操作棋子移动时，不等host返回就直接在视觉上移动黑方棋子，等host收到这个操作指令后，要么不再下发client端，要么client端判断是自己的操作后不再重复移动，避免视觉上卡顿回退。另外，host操作红方棋子时通知client视觉上移动红方棋子。
    
- **通信协议**: Mirror 的高层 API (HLAPI)，使用 [Command] 和 [ClientRpc] 进行指令的收发和状态的广播。
    

#### **3.4.2 核心网络数据流**

|   |   |   |   |   |
|---|---|---|---|---|
|发起者|目标|动作|Mirror API|职责|
|Client|Host/Server|发送指令|[Command]|将玩家意图 (ICommand) 发送到 Host。|
|Host/Server|Client|广播权威状态|[ClientRpc(target=All)]|将 Host 计算后的权威 GameState 广播给所有客户端。|

#### **3.4.3 接口设计：INetworkService**

这是上层逻辑与底层网络通信的唯一桥梁。

**路径**: Assets/Script/_Core/Networking/INetworkService.cs

|   |   |   |
|---|---|---|
|成员类型|成员名称|职责|
|**Events**|OnConnected|成功启动/连接时触发。|
||OnDisconnected|断开连接时触发。|
||OnGameStateUpdated(GameState)|接收到 Host 权威状态时触发。|
||OnLobbyStateUpdated(LobbyState)|(Steam 集成) 大厅信息更新时触发。|
|**Properties**|IsHost { get; }|当前实例是否为 Host/Server。|
||IsConnected { get; }|当前是否处于连接状态。|
|**Methods**|StartHost(GameSetupData)|启动 Host 模式（同时启动 Server 和 Client）。|
||StartClient(string address)|连接到指定地址的 Server。|
||Disconnect()|断开连接。|
||SendCommand(ICommand command)|**核心方法**。向 Host 发送一个指令。|

#### **3.4.4 实现类 1：MirrorService (在线模式)**

**路径**: Assets/Script/_Core/Networking/MirrorService.cs

- 客户端在发送 ICommand 时，会将其序列化，并附带一个 **本地的指令序列号 (Local Command ID)**。
    
- 客户端在本地会维护一个 **预测指令队列**，存储已发送但尚未得到 Host 确认的指令。
    

- Host 收到 [Command] 后：
    
    1. **逻辑校验**: CommandProcessor 严格校验：行动点、CD、移动路径、吃子权限等。
        
    2. **执行逻辑**: 如果校验通过，执行 command.Execute(GameState)。
        
    3. **结果同步**: 逻辑状态 (GameState) 发生变化后，Host 立即通过 RpcReceiveGameState 广播新的权威 GameState。
        

- Host 广播 GameState，包含最新的棋子逻辑位置、状态和行动点等信息。
#### **3.4.5 客户端预测（视觉平滑）的实现要点 **

客户端的 **InputController** 和 **PieceView** 需要共同协作，实现低延迟的视觉体验。

1. **InputController 的职责 (Client)**:
    
    - 当玩家尝试移动棋子时：
        
        1. 创建 MoveCommand。
            
        2. 调用 MirrorService.SendCommand(command) 发送给 Host。
            
        3. 立即调用 **本地的 PieceView** 的方法，使其开始从当前逻辑格点 **平滑移动** 到目标格点。
            
        4. 如果 Host 裁决失败，棋子会在平滑移动的过程中突然停止，或被校正回上一个权威位置。
            
2. **PieceView 的职责 (Client)**:
    
    - PieceView 现在是 **视觉插值器**，它不关心移动是否合法，只负责将棋子在两个逻辑格点之间平滑移动。
        
    - **逻辑位置存储**: PieceView 内部不存储逻辑位置，它只存储当前正在平滑移动的 **目标格点**。
        
    - **权威状态接收**:
        
        - BoardView 收到 Host 的 GameState 后，通知所有 PieceView 最终的 **权威逻辑位置**。
            
        - 如果 PieceView 正在平滑移动，新位置与目标位置一致，则继续移动。
            
        - 如果 PieceData 状态发生变化 (例如：PieceStatus.None 死亡，或 PieceData.position 被修正)，则 PieceView 立即停止所有本地预测的移动，播放死亡动画或直接跳到权威位置。
            

**结论**: 逻辑位置 (PieceData.position) 永远只由 Host 决定和同步，客户端的 PieceView 只是负责将棋子从旧的权威位置，以平滑动画的方式移动到 Host 设定的新权威位置，以掩盖网络延迟。客户端预测仅限于视觉反馈，而非逻辑处理。

#### **3.4.6 实现类 2：OfflineService (单机模式)**

**路径**: Assets/Script/_Core/Networking/OfflineService.cs

- 这是一个纯 C# 类，用于完美模拟 Host 环境下的逻辑流程。
    
- SendCommand 直接转发到本地的 CommandProcessor。
    
- 它订阅本地 CommandProcessor 的状态更新事件，然后触发自己的 OnGameStateUpdated 事件，以模拟网络接收延迟。
    

#### **3.4.7 服务定位器：NetworkServiceProvider**

**路径**: Assets/Script/_Core/Networking/NetworkServiceProvider.cs

- 负责管理 INetworkService 的生命周期和实例切换。所有模块都通过 NetworkServiceProvider.Instance 访问网络功能。
    

---

## **第三部分：Steam API 与 Lobby 抽象**

为了满足 Steam 平台要求，我们对 Steamworks API 进行了抽象。

### **3.5 Steam 集成与 Lobby 管理 (_Core/Steam)**

#### **3.5.1 SteamManager**

**路径**: Assets/Script/_Core/Steam/SteamManager.cs

- 继承 PersistentSingleton。
    
- 职责：初始化 Steamworks.NET，处理所有 Steam API 的回调。
    
- 功能：启动时调用 SteamAPI.Init()。
    

#### **3.5.2 ILobbyService**

- 职责：抽象 Steam 大厅（Lobby）功能，提供平台无关的房间管理接口。
    
- 功能：
    
    - CreateLobby(int maxPlayers, bool isPublic)
        
    - JoinLobby(CSteamID lobbyId)
        
    - GetLobbies() (用于大厅列表展示)
        

#### **3.5.3 SteamLobbyService**

- 职责：实现 ILobbyService，将调用映射到 SteamMatchmaking API。
    
- **关键点**: 当 Host 创建 Steam Lobby 成功后，它会将 Lobby ID（CSteamID）作为房间标识，并启动 Mirror Host。其他玩家通过 Steam 邀请或大厅列表加入该 Lobby 后，再使用 Lobby 的连接信息 (SteamNetworking.ConnectP2P) 来启动 Mirror Client。
    

---

## **第四部分：对现有架构的调整与校正**

### **4.1 GameLoopController 调整**

**路径**: Assets/Scripts/_App/GameManagement/GameLoopController.cs

- **移除 CommandProcessor 的 Tick 调用**: 因为实时模式的行动点恢复现在交由 Host 的 GameLoopController 在 **FixedUpdate** 中驱动，并通过 _commandProcessor.Tick() 驱动 IGameModeLogic.OnTick(state) 来实现。
    


---