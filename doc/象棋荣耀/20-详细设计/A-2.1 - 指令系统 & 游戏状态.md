### **详细设计文档: A-2.1 - 指令系统 & 游戏状态**

**文档版本**: 1.0  
**设计目标**: 构建游戏的核心逻辑驱动机制。该机制基于指令模式(Command Pattern)和单一状态树(Single State Tree)，确保所有游戏行为都是可预测、可追溯、可回放、且易于网络同步的。

---

### **模块 1: Core.GameState - 游戏状态机**

#### **1.1. 模块目标 (Goal)**

定义一个单一、权威的数据结构(GameState)，用于完整描述任何时刻的游戏对局状态。游戏中的所有逻辑判断和渲染表现，都必须且只能依赖于这份数据，它  
是“唯一的事实来源 (Single Source of Truth)”。

#### **1.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Script/_Core/GameState/
    
- **类设计**:
    
    1. **GameState**
        
        - **类型**: class (需要实现FishNet的INetworkSerializable接口)
            
        - **职责**: 包含一局游戏中所有动态变化的数据。它是游戏世界的一个完整快照。
            
        - **详细功能说明**: 这个类本身不包含任何逻辑。它是一个纯粹的数据容器。任何对它的修改都必须通过CommandProcessor来完成。网络同步的核心就是同步GameState的变化（或者更优地，同步导致这些变化的指令）。
            
        - **关键成员**:
            
            - public int tick;: 游戏逻辑帧或回合数。每次状态更新时自增，用于状态同步和调试。
                
            - public Dictionary<int, PieceData> pieces;: **核心数据**。使用棋子uniqueId作为Key，方便快速查找和更新。存储了棋盘上所有棋子（无论死活）的当前数据。
                
            - public float[] actionPoints;: 玩家的行动点。索引0为红方(PlayerTeam.Red)，索引1为黑方(PlayerTeam.Black)。
                
            - public float[] skillCooldowns;: 技能冷却计时器。这个设计比较复杂，需要一个Dictionary<int, float> skillCooldowns，Key是代表某个特定技能的唯一ID（例如，可以通过pieceId和skillSlot组合生成），Value是剩余冷却时间。
                
            - public GamePhase phase;: 游戏当前阶段，枚举类型，如 GamePhase { Setup, Playing, Paused, GameOver }。
                
            - public PlayerTeam winner;: 游戏结束时的胜利方。
                
            - public PlayerTeam currentTurn;: 仅在回合制模式下有意义，表示当前轮到哪一方行动。
                

---

### **模块 2: Core.Command - 指令系统**

#### **2.1. 模块目标 (Goal)**

建立一套严格的指令处理流程。游戏中任何导致GameState变化的意图（玩家输入、AI决策、服务器指令）都必须被封装成一个“指令”对象。这个对象将被发送到一个中心化的“指令处理器”，由它来验证和执行，最终改变GameState。

#### **2.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Script/_Core/Command/
    
- **接口与基类设计**:
    
    1. **ICommand**
        
        - **类型**: 接口
            
        - **职责**: 定义所有指令的通用契约。
            
        - **详细功能说明**: 任何希望修改GameState的动作都必须实现此接口。为网络传输，它需要是可序列化的（FishNet通过代码生成自动处理，我们只需标记即可）。
            
        - **关键方法**:
            
            - void Execute(GameState state);: **核心方法**。在此方法中编写修改GameState的逻辑。参数是当前的游戏状态，指令将直接对其进行修改。
                
            - // bool Validate(GameState state);: (可选但推荐) 用于在执行前验证该指令在当前状态下是否合法。例如，移动指令需要验证路径是否合法、行动点是否足够。
                
- **具体指令类 (实现 ICommand)**:
    
    - **职责**: 封装一个具体的游戏动作及其所需的所有参数。
        
    - **详细功能说明**: 这些类是简单的数据载体，逻辑主要在Execute方法中。它们将被玩家输入模块、AI模块创建，然后发送给CommandProcessor。
        
    
    1. **MoveCommand**:
        
        - **成员**: int pieceId;, Vector2Int targetPosition;
            
        - **Execute逻辑**:
            
            1. 在state.pieces中找到pieceId对应的PieceData。
                
            2. 修改其position为targetPosition。
                
            3. 修改为PieceStatus.Moving。
                
            4. 扣除对应玩家的行动点。
                
    2. **UseSkillCommand**:
        
        - **成员**: int casterPieceId;, int skillId;, Vector2Int targetGrid; (格子目标), int targetPieceId; (棋子目标)
            
        - **Execute逻辑**:
            
            1. 根据skillId从SkillConfig获取技能信息。
                
            2. 在state上应用技能效果（例如，修改另一个棋子的state为Stunned，或从pieces字典中移除一个棋子）。
                
            3. 在state.skillCooldowns中设置该技能的冷却时间。
                
    3. **EndTurnCommand**: (回合制专用)
        
        - **成员**: PlayerTeam team;
            
        - **Execute逻辑**:
            
            1. 验证team是否等于state.currentTurn。
                
            2. 切换state.currentTurn到另一方。
                
- **核心处理器设计**:
    
    1. **CommandProcessor**
        
        - **类型**: 普通C#类 (非MonoBehaviour)
            
        - **职责**: 游戏逻辑的核心驱动器。接收指令，验证指令，执行指令，并持有和更新GameState。
            
        - **详细功能说明**: 这是一个中心枢纽。在单机模式下，它在本地运行。在联机模式下，权威的CommandProcessor运行在服务器（或主机）上，客户端只有一个“哑”版本用于客户端预测。
            
        - **关键成员**:
            
            - private GameState currentGameState;
                
            - private IGameModeLogic gameModeLogic; (来自A-3.1模块，用于验证指令)
                
            - public void SetGameMode(IGameModeLogic logic);: 设置当前游戏模式的规则集。
                
            - public void ProcessCommand(ICommand command);: **核心入口方法**。
                
                - **流程**:
                    
                    1. 调用gameModeLogic.ValidateCommand(command, currentGameState)进行合法性验证。
                        
                    2. 如果验证通过，调用command.Execute(currentGameState)。
                        
                    3. currentGameState.tick++。
                        
                    4. 广播一个OnGameStateUpdated事件，携带更新后的GameState，供表现层(View)监听。
                        
            - public GameState GetCurrentState();: 提供对当前状态的只读访问。
                

#### **2.3. Unity工作流 (Unity Workflow)**

1. **游戏启动流程**:
    
    - 一个名为GameLoopController的MonoBehaviour（单例）在对战场景加载时被激活。
        
    - GameLoopController根据GameSetupData创建并初始化一个新的GameState对象。
        
    - GameLoopController创建CommandProcessor实例，并将GameState注入进去。
        
    - GameLoopController根据游戏模式，创建对应的IGameModeLogic（例如 new RealTimeLogic()），并通过SetGameMode方法设置给CommandProcessor。
        
2. **玩家输入到状态改变的完整流程**:
    
    1. 玩家在屏幕上点击，InputController (来自A-4.1) 捕捉到这个操作。
        
    2. InputController判断玩家意图（例如，选择棋子，然后点击目标点）。
        
    3. InputController创建一个MoveCommand实例，并填充参数（pieceId, targetPosition）。
        
    4. InputController将这个command对象发送给网络层INetworkService.SendToServer(command)（在单机模式下，OfflineService会直接将其路由到本地的CommandProcessor）。
        
    5. 服务器/主机的CommandProcessor收到指令，执行ProcessCommand方法。
        
    6. GameState被改变。
        
    7. CommandProcessor广播OnGameStateUpdated事件。
        
    8. 表现层（如PieceView）监听到事件，获取到新的GameState，发现自己的PieceData位置变了，于是播放从旧位置到新位置的移动动画。