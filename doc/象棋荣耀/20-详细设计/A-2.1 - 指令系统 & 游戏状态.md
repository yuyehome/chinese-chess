### **详细设计文档: A-2.1 - 指令系统 & 游戏状态 **

**文档版本**: 2.0  
**设计目标**: 构建游戏的核心逻辑驱动机制。该机制基于 **本地权威状态 (Local Authority State)** 和 **指令模式 (Command Pattern)**，确保所有游戏行为都是可预测、可追溯、可回放的。同时，**将状态变更解耦为原子事件**，为高效、低带宽的网络同步提供支持。

---

### **模块 1: Core.GameState - 游戏状态机**

#### **1.1. 模块目标 (Goal)**

定义一个单一、权威的数据结构(GameState)，用于完整描述任何时刻的游戏对局状态。游戏中的所有逻辑判断和渲染表现，都必须且只能依赖于这份数据，它是“唯一的事实来源 (Single Source of Truth)”。**此模块设计保持不变，它是整个架构的稳定基石。**

#### **1.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Script/_Core/GameState/
    
- **类设计**:
    
    1. **GameState**
        
        - **类型**: class
            
        - **职责**: 包含一局游戏中所有动态变化的数据。它是游戏世界的一个完整快照。
            
        - **详细功能说明**: 这是一个纯粹的数据容器。在**任何一个实例**中（Host端或Client端），它都代表了该实例所知的游戏世界。Host端的GameState是权威的，Client端的GameState是Host权威状态的一个**最终一致性副本**。
            
        - **关键成员**:
            
            - public int tick;: 游戏逻辑帧或回合数。每次状态更新时自增，用于状态同步和调试。
                
            - public Dictionary<int, PieceData> pieces;: **核心数据**。使用棋子uniqueId作为Key，方便快速查找和更新。存储了棋盘上所有棋子的当前数据。
                
            - public float[] actionPoints;: 玩家的行动点。索引0为红方(PlayerTeam.Red)，索引1为黑方(PlayerTeam.Black)。
                
            - public Dictionary<int, float> skillCooldowns;: 技能冷却计时器。Key是代表某个特定技能的唯一ID，Value是剩余冷却时间。
                
            - public GamePhase phase;: 游戏当前阶段，枚举类型，如 GamePhase { Setup, Playing, Paused, GameOver }。
                
            - public PlayerTeam winner;: 游戏结束时的胜利方。
                
            - public PlayerTeam currentTurn;: 仅在回合制模式下有意义，表示当前轮到哪一方行动。
                

---

### **模块 2: Core.Command - 指令与事件系统**

#### **2.1. 模块目标 (Goal)**

建立一套严格的逻辑处理流程。

1. **输入 -> 指令**: 游戏中任何导致状态变化的**意图**（玩家输入、AI决策）都必须被封装成一个“指令(Command)”对象。
    
2. **指令 -> 逻辑**: 指令被发送到一个中心化的“指令处理器(CommandProcessor)”，由它来验证和执行。
    
3. **逻辑 -> 事件**: CommandProcessor 执行指令并修改权威GameState后，**不直接广播GameState**，而是生成并广播一个或多个描述该变化的“**原子状态变更事件(State Change Event)**”。
    

#### **2.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Script/_Core/Command/
    
- **接口与基类设计**:
    
    1. **ICommand**
        
        - **类型**: 接口
            
        - **职责**: 定义所有**本地逻辑指令**的通用契约。这些指令直接操作GameState。
            
        - **关键方法**:
            
            - void Execute(GameState state);: **核心方法**。在此方法中编写修改GameState的逻辑。
                
- **具体指令类 (实现 ICommand)**:
    
    - **职责**: 封装一个具体的游戏动作。这些类**只在权威端(Host/单机)被创建和执行**。
        
    
    1. **MoveCommand**:
        
        - **成员**: int pieceId;, Vector2Int targetPosition;, PlayerTeam requestTeam;
            
        - **Execute逻辑**: 在state中找到棋子，修改其位置，扣除行动点。
            
    2. **UseSkillCommand**:
        
        - **成员**: int casterPieceId;, int skillId;, Vector2Int targetGrid; ...
            
        - **Execute逻辑**: 在state中应用技能效果，设置技能冷却。
            
    3. **EndTurnCommand**: (回合制专用)
        
        - **成员**: PlayerTeam team;
            
        - **Execute逻辑**: 切换state.currentTurn。
            
- **核心处理器设计**:
    
    1. **CommandProcessor**
        
        - **类型**: 普通C#类 (非MonoBehaviour)
            
        - **职责**: **权威游戏逻辑的核心驱动器**。接收指令，验证指令，执行指令，修改权威GameState，并**广播原子状态变更事件**。
            
        - **详细功能说明**: 这是逻辑的中心枢纽。它**只在Host或单机模式下权威运行**。客户端没有CommandProcessor。
            
        - **关键成员**:
            
            - private GameState authoritativeGameState;
                
            - private IGameModeLogic gameModeLogic;
                
            - public event Action<int, Vector2Int> OnPieceMoved;: **事件示例1**。参数: pieceId, newPosition。
                
            - public event Action<PlayerTeam, float> OnActionPointsUpdated;: **事件示例2**。参数: team, newAmount。
                
            - public event Action<int> OnPieceRemoved;: **事件示例3**。参数: pieceId。
                
            - // ... 更多具体的原子事件
                
        - **关键方法**:
            
            - public void SetGameMode(IGameModeLogic logic);: 设置当前游戏模式的规则集。
                
            - public void ProcessCommand(ICommand command);: **核心入口方法**。
                
                - **流程**:
                    
                    1. 调用gameModeLogic.ValidateCommand(command, authoritativeGameState)进行合法性验证。
                        
                    2. 如果验证通过，**记录下执行前的状态快照**（可选，用于生成事件）。
                        
                    3. 调用command.Execute(authoritativeGameState)。
                        
                    4. authoritativeGameState.tick++。
                        
                    5. **对比执行前后的状态，识别出所有变化，并触发对应的原子事件**。例如，如果一个棋子位置变了，就触发OnPieceMoved事件。
                        
            - public GameState GetCurrentState();: 提供对权威状态的只读访问。
                

#### **2.3. Unity工作流 (Unity Workflow)**

1. **游戏启动流程 (Host/单机)**:
    
    - GameLoopController创建并初始化一个新的GameState对象。
        
    - GameLoopController创建CommandProcessor实例，并将GameState注入。
        
    - GameLoopController根据游戏模式创建IGameModeLogic，并设置给CommandProcessor。
        
    - GameLoopController**订阅CommandProcessor的所有原子事件**，并将这些事件**通过网络层(INetworkService)广播出去**。
        
2. **一次完整操作的数据流 (以网络对战为例)**:
    
    1. **客户端(Client)**: InputController捕捉到玩家点击，创建一个**可序列化的网络指令数据包** (例如 NetworkCommand 结构体，**而非ICommand接口**)。
        
    2. **客户端(Client)**: InputController将这个NetworkCommand通过INetworkService.SendCommandToServer()发送给Host。
        
    3. **服务器(Host)**: MirrorService收到NetworkCommand，将其**解析并转换**为一个本地的、实现了ICommand接口的指令对象 (例如 new MoveCommand(...))。
        
    4. **服务器(Host)**: MirrorService将这个ICommand对象交给本地的CommandProcessor处理。
        
    5. **服务器(Host)**: CommandProcessor执行指令，修改权威GameState，然后触发了OnPieceMoved和OnActionPointsUpdated两个事件。
        
    6. **服务器(Host)**: GameLoopController监听到这两个事件，调用INetworkService的RpcOnPieceMoved()和RpcOnActionPointsUpdated()方法，将事件广播给所有客户端。
        
    7. **客户端(Client)**: MirrorService接收到RPC调用，**在本地的GameState副本上应用这些变更**（例如，localGameState.pieces[id].position = newPos;）。
        
    8. **客户端(Client)**: 客户端的BoardView通过常规的事件或轮询检测到本地GameState发生变化，从而更新棋子的视觉表现。