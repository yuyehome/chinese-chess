### **《象棋荣耀》B-1.1 模块开发前置分析：传统回合制模式 (M1) (修订版 v1.1)**

#### **1. 核心目标 (Overall Goal)**

实现一个**可配置的**、遵循**定制版**中国象棋规则的回合制对战模式。此模式不仅要支持标准的1v1对战，还需要支持2V2模式。并且其底层架构还必须为未来的残局模式、等扩展功能做好准备。

#### **2. 核心游戏实体与状态 (Core Entities & State) - 扩展性设计**

1. **棋盘 (Board):**
    
    - **尺寸可配置:** 不再是固定的9x10。系统需要支持任意尺寸的棋盘，如标准的9x10和为2v2准备的18x10。这将通过一个数据对象（如BoardData）来定义。
        
2. **棋子 (Pieces):**
    
    - 数据结构保持不变（ID, 类型, 阵营, 位置, 状态）。
        
3. **游戏状态 (Game State):**
    
    - **阵营扩展:** PlayerTeam 枚举将包含 Red, Black, Blue, Green，为2v2及更多模式预留。
        
    - **布局可配置:** 游戏开局的棋子布局将通过一个配置文件（如GameSetupData）加载，而不是硬编码。这将直接支持“残局模式”等玩法。
        
    - **当前回合方 (Current Turn):** 逻辑保持不变，但能处理多于两个的阵营轮转。
        
    - **游戏阶段 (Game Phase):** 保持不变（进行中、游戏结束）。
        

#### **3. 游戏流程 (Game Flow)**

基本流程不变，但在细节上增加和调整：

- **回合循环中:**
    
    - **“求和”流程:**
        
        1. 玩家A点击“求和”按钮。
            
        2. 系统向对方玩家B发送“求和请求”。
            
        3. 玩家B界面出现弹窗，可选择“同意”或“拒绝”。
            
        4. 若B同意，游戏立即以“和棋”结束。
            
        5. 若B拒绝，游戏继续，且玩家A在短期内（例如2分钟）不能再次发起求和。
            
- **游戏结束 (Game Over):**
    
    - 结束条件被明确为以下几种：
        
        1. 一方的“将/帅”被吃掉。
            
        2. 一方玩家点击“投降”。
            
        3. 一方玩家接受了另一方的“求和”请求。
            
        4. 玩家掉线（按投降处理）。
            

#### **4. 详细游戏规则 (Detailed Game Rules) - 定制版**

这是本次修订的核心。我们将在标准规则基础上进行以下**关键性简化和修改**：

**核心规则简化：**

- **取消强制“应将”规则:** 玩家即使处于被“将军”的状态，也可以移动其他棋子。系统**不会**强制玩家必须解除将军。
    
- **取消“防送将”规则:** 玩家可以走一步棋，使得自己的“将/帅”直接暴露在对方的攻击范围内。
    
- **总结:** 这两条修改赋予了玩家极大的自由度，也允许“菜鸟”玩家犯下致命错误，增加了游戏的戏剧性。从开发角度看，这**极大简化了 ValidateCommand 的验证逻辑**，我们不再需要进行复杂的“将军”和“解将”推演。
    

**各棋子移动规则:**

- **将/帅 (General):**
    
    - 移动规则不变（九宫格内，每次一格）。
        
    - **特殊规则 - 王见王 (激光炮):**
        
        - 这是一个**主动攻击规则**，而非移动限制。
            
        - 当一方的将/帅移动后，如果与对方的将/帅在同一条竖线上，且中间没有任何棋子阻挡，则视为一次成功的“攻击”。
            
        - **效果:** 对方的将/帅**立即被吃掉**，状态变为“死亡”，游戏结束。
            
        - **表现形式:** 移动到位后，从攻击方的将/帅处发射一道激光特效，击中并消灭对方的将/帅。
            
- **士/仕 (Advisor), 象/相 (Elephant), 马 (Horse), 车 (Chariot), 炮 (Cannon), 兵/卒 (Soldier):**
    
    - 所有这些棋子的移动和吃子规则均遵循**标准中国象棋规则**（如蹩马腿、塞象眼、炮需隔山打牛等），但不受上述“应将/送将”规则的限制。
        

#### **5. 胜利与失败条件 (Win/Loss Conditions) - 修订**

- **胜利:**
    
    - 成功吃掉对方的“将/帅”（包括通过“王见王”规则）。
        
    - 对方玩家“投降”。
        
- **失败:**
    
    - 己方的“将/帅”被吃掉。
        
    - 自己“投降”。
        
- **和棋:**
    
    - 向对方“求和”并被接受。
        
- **移除的规则:**
    
    - **困毙 (Stalemate):** 不再是自动判负的条件。如果一方被困毙，该玩家必须自己选择“投降”，否则游戏将继续（尽管他/她无法移动）。
        

---

#### **6. 视觉表现与用户体验 (Visuals & User Experience) - 新增模块**

这些是与核心逻辑解耦的纯表现层任务，但同样重要。

1. **棋盘网格程序化生成 (可选项，建议实施):**
    
    - **需求:** 使用代码（如Line Renderer或Shader）绘制棋盘的网格线，而不是使用一张贴图。
        
    - **优点:**
        
        - **高可定制性:** 可以轻松改变线条颜色、粗细、材质，以适应不同的棋盘模型（如沙场、石台）。
            
        - **动态效果:** 可以实现您提到的“线条从将/帅位置动态延伸铺满棋盘”的开局动画，非常酷炫。
            
    - **可行性:** 完全可行，且性能开销很低。我们可以创建一个 BoardGridRenderer.cs 脚本专门负责此事。我建议将此作为一个独立的、优先级较高的视觉任务来完成。
        
2. **玩家操作反馈:**
    
    - **棋子悬浮:** 当玩家鼠标悬停或选中己方棋子时，该棋子模型在Y轴上轻微上浮，并可能伴有发光或呼吸效果。
        
    - **合法落点高亮:**
        
        - **可移动点:** 在棋盘上显示半透明的标记（如绿点）。
            
        - **可攻击点:** 在可吃掉的敌方棋子脚下显示一个更醒目的标记（如红圈），或直接让该敌方棋子模型高亮/变色。
            
3. **棋子移动动画:**
    
    - **马/象:** 移动时，模型沿一条较低的抛物线轨迹跳跃到目标点。
        
    - **炮:**
        
        - **移动时:** 沿棋盘表面平移。
            
        - **攻击时:** 模型沿一条较高的抛物线轨迹飞跃“炮架”，落在目标点。
            
    - **其他棋子:** 沿棋盘表面线性平移到目标点。
        



### **详细设计文档: B-1.1 - 回合制模式逻辑 (M1) (修订版 v1.1)**

**文档版本**: 1.1  
**设计目标**: 实现一个**架构灵活、规则定制**的传统中国象棋(M1)玩法。该模块需支持可配置的棋盘尺寸与初始布局，实现简化的、更具娱乐性的核心规则（允许送将、激光王见王），并为未来的2v2等多阵营模式奠定基础。

---

### **模块 1: Gameplay.Rules - 公共游戏规则计算库**

#### **1.1. 模块目标 (Goal)**

提供一个纯粹的、无状态的、可被所有游戏模式复用的棋子移动规则计算库。它只负责根据棋子类型和位置，生成理论上的移动路径，不考虑棋盘上的任何其他棋子。

#### **1.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Scripts/_Gameplay/Rules/
    
- **类设计**:
    
    1. **PieceMovementGenerator.cs**
        
        - **类型**: static class
            
        - **职责**: 为每种棋子生成“理论上”所有可能的移动目标点。
            
        - **关键方法 (示例)**:
            
            - public static List<Vector2Int> GetTheoreticalMoves_Chariot(Vector2Int fromPos, Vector2Int boardSize)
                
                - 说明: 返回fromPos位置的车在boardSize大小的棋盘上所有直线可达的点。
                    
            - public static List<Vector2Int> GetTheoreticalMoves_Horse(Vector2Int fromPos, Vector2Int boardSize)
                
                - 说明: 返回所有“日”字格的目标点，并进行边界检查。
                    
            - public static List<Vector2Int> GetTheoreticalMoves_Elephant(Vector2Int fromPos, PlayerTeam team, Vector2Int boardSize)
                
                - 说明: 返回所有“田”字格的目标点，并根据阵营判断是否过河。
                    
            - ... (为所有棋子类型提供类似的方法)
                

---

### **模块 2: Gameplay.TurnBased - 回合制逻辑实现**

#### **2.1. 模块目标 (Goal)**

实现 IGameModeLogic 接口，封装所有 M1 模式独有的规则（回合轮转、合法性验证、胜负裁定）。

#### **2.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Scripts/_Gameplay/TurnBased/
    
- **类设计**:
    
    1. **TurnBasedLogic.cs**
        
        - **类型**: class TurnBasedLogic : IGameModeLogic
            
        - **职责**: M1模式的权威规则处理器。
            
        - **关键方法实现 (IGameModeLogic 接口)**:
            
            - **Initialize(GameState state, GameSetupData setupData)**:
                
                1. 根据 setupData 设置 state.boardSize。
                    
                2. 根据 setupData 的棋子布局列表，初始化 state.pieces 字典。
                    
                3. 设置初始回合方 state.currentTurn = PlayerTeam.Red。
                    
            - **ValidateCommand(ICommand command, GameState state)**:
                
                1. **通用检查**: 检查发起指令的玩家是否是 state.currentTurn 的当前回合方。
                    
                2. **指令类型分派**:
                    
                    - **MoveCommand**:  
                        a. 获取要移动的棋子 pieceData。  
                        b. 调用 GetValidMovesForPiece(pieceData, state) 获取该棋子在当前局面下所有合法的落点。  
                        c. 检查 MoveCommand.targetPosition 是否在该合法落点列表内。**注意：此验证过程不考虑“应将”和“送将”，极大简化了逻辑。**
                        
                    - **RequestDrawCommand**:  
                        a. 检查当前 GameState 是否允许发起求和（例如，是否有求和冷却）。
                        
                    - **AcceptDrawCommand**:  
                        a. 检查 GameState 中是否存在来自对方的有效求和请求。
                        
                    - **ResignCommand**:  
                        a. 始终返回 true。
                        
            - **OnTick(GameState state, float deltaTime)**: 留空。
                
        - **新增公共方法**:
            
            - **public List<Vector2Int> GetValidMovesForPiece(PieceData piece, GameState state)**:
                
                1. 根据 piece.type 调用 PieceMovementGenerator 获取理论移动点。
                    
                2. 遍历理论移动点，根据 state 中的棋子布局进行筛选：
                    
                    - **路径阻挡**: 检查路径上是否有其他棋子（对车、马、象、炮生效）。
                        
                    - **落点**:
                        
                        - 如果落点有**己方**棋子，非法。
                            
                        - 否则（空点或敌方棋子），合法。
                            
                3. 返回所有筛选后合法落点的列表。此方法将被 InputController 调用以显示高亮。
                    

---

### **模块 3: Core.Command - 指令逻辑扩展**

#### **3.1. 模块目标 (Goal)**

扩展和实现回合制模式所需的具体指令。

#### **3.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Scripts/_Core/Command/
    
- **类修改与新增**:
    
    1. **MoveCommand.cs**
        
        - **Execute(GameState state) 方法**:
            
            1. 获取目标位置 targetPos。
                
            2. 检查 targetPos 上是否有棋子 targetPiece。
                
            3. **吃子**: 如果存在 targetPiece，将其状态设置为 PieceStatus.Dead。
                
            4. **移动**: 更新发起棋子的 position 为 targetPos。
                
            5. **王见王检查**: 调用 TurnBasedGameRules.CheckForFlyingGeneral(state, movingPiece)。如果该检查导致对方将帅死亡，则直接进入游戏结束流程。
                
            6. **切换回合**: state.currentTurn 切换到下一个玩家。
                
            7. **检查游戏结束**: 调用 TurnBasedGameRules.CheckGameOver(state)。
                
    2. **RequestDrawCommand.cs (新增)**
        
        - **Execute(GameState state)**: 在 GameState 中记录一个求和请求状态，例如 state.drawRequestFrom = this.requestingPlayer。
            
    3. **AcceptDrawCommand.cs (新增)**
        
        - **Execute(GameState state)**: 设置 state.phase = GamePhase.GameOver 和 state.winner = PlayerTeam.None (代表和棋)。
            
    4. **ResignCommand.cs (新增)**
        
        - **Execute(GameState state)**: 设置 state.phase = GamePhase.GameOver 并根据投降方设置 state.winner。
            

---

### **模块 4: Gameplay.TurnBased - 胜利条件判断**

#### **4.1. 模块目标 (Goal)**

提供一组独立的、无状态的规则检查方法，用于判断游戏是否结束。

#### **4.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Scripts/_Gameplay/TurnBased/
    
- **类设计**:
    
    1. **TurnBasedGameRules.cs**
        
        - **类型**: static class
            
        - **职责**: 封装M1模式下的核心裁决逻辑。
            
        - **关键方法**:
            
            - public static void CheckGameOver(GameState state):
                
                1. 在 state.pieces 中查找双方的“将/帅”。
                    
                2. 如果某一方的“将/帅”的 status 为 Dead，则游戏结束，设置 state.phase = GamePhase.GameOver 和 state.winner。
                    
            - public static void CheckForFlyingGeneral(GameState state, PieceData movedPiece):
                
                1. 检查 movedPiece 是否为“将/帥”。
                    
                2. 如果是，获取其位置和对方“将/帥”的位置。
                    
                3. 判断两者是否在同一竖线，且中间无任何其他棋子。
                    
                4. 如果条件满足，将对方“将/帥”的 status 设为 Dead。
                    

---

### **模块 5: Unity 工作流与视图层对接**

1. **游戏启动**: GameLoopController 根据配置创建 TurnBasedLogic 实例并交给 CommandProcessor。
    
2. **显示合法移动**:
    
    - InputController 在玩家选中棋子后，调用 TurnBasedLogic.GetValidMovesForPiece()。
        
    - BoardView 接收返回的合法落点列表，并负责：
        
        - 在空地落点生成“可移动”标记。
            
        - 在有敌方棋子的落点生成“可攻击”标记（或高亮敌方棋子）。
            
3. **将军提示 (视觉)**: BoardView 可以在每次 GameState 更新后，自行检查“将军”状态，并为被将军的棋子添加警告特效。这是一个纯视觉表现，不影响任何游戏逻辑。
    
4. **移动动画**: PieceView 在接收到其对应 PieceData 的位置变更事件后，根据棋子类型（马、象、炮等）播放预设的移动或攻击动画。
    
5. **棋盘网格生成**: 建议新建 _App/View/BoardGridRenderer.cs 脚本，负责程序化生成网格和实现开局的动态延伸动画。此模块与游戏逻辑完全解耦。