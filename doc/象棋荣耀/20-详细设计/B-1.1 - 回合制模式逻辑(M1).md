### **详细设计文档: B-1.1 - 回合制模式逻辑 (M1)**

**文档版本**: 1.0  
**设计目标**: 实现传统中国象棋(M1)的完整玩法。这包括标准的回合制轮转、所有棋子的走子和吃子规则、将军/应将逻辑（虽不强制，但需提示）、以及最终的胜利/失败条件判断。

---

### **模块 1: Gameplay.Rules - 公共游戏规则**

#### **1.1. 模块目标 (Goal)**

根据新方案C，提供一个纯粹的、无状态的、可被所有游戏模式复用的棋子移动规则计算库。

#### **1.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Script/_Gameplay/Rules/
    
- **类设计**:
    
    1. **PieceMovementGenerator**
        
        - **类型**: static class
            
        - **职责**: 为每种棋子生成“理论上”所有可能的移动路径，不考虑任何棋盘上的障碍。
            
        - **详细功能说明**:
            
            - **路径定义**: “路径”是一个Vector2Int[]数组，包含了从起点到终点所有必须经过的格子。对于直线移动的棋子，路径就是起点和终点之间的所有格子。对于“马”，路径包含拐点。
                
            - **返回值**: List<Vector2Int[]>，即所有可能路径的列表。
                
        - **关键方法**:
            
            - public static List<Vector2Int[]> GetPathsFor_Chariot(Vector2Int fromPos)
                
            - public static List<Vector2Int[]> GetPathsFor_Horse(Vector2Int fromPos)
                
            - public static List<Vector2Int[]> GetPathsFor_Elephant(Vector2Int fromPos, PlayerTeam team) (象需要知道阵营来判断是否过河)
                
            - public static List<Vector2Int[]> GetPathsFor_Advisor(Vector2Int fromPos, PlayerTeam team) (士/仕需要知道阵营来判断九宫格)
                
            - public static List<Vector2Int[]> GetPathsFor_General(Vector2Int fromPos, PlayerTeam team)
                
            - public static List<Vector2Int[]> GetPathsFor_Cannon(Vector2Int fromPos)
                
            - public static List<Vector2Int[]> GetPathsFor_Soldier(Vector2Int fromPos, PlayerTeam team) (兵/卒需要知道阵营和位置来判断是直走还是横走)
                
    2. **AvailableMoveCalculator** (将会在M1和M2/M3中以不同方式使用)
        
        - 这个类我们将在B-2.1中为实时模式进行完整设计。在B-1.1回合制中，我们可以先定义一个简化的、专门用于回合制的版本或用法。
            

---

### **模块 2: Gameplay.TurnBased - 回合制逻辑实现**

#### **2.1. 模块目标 (Goal)**

实现IGameModeLogic接口，封装所有M1模式独有的规则和逻辑。

#### **2.2. 模块内容与技术方案 (Code Design & Tech Plan)**

- **代码路径**: Assets/Script/_Gameplay/TurnBased/
    
- **类设计**:
    
    1. **TurnBasedLogic**
        
        - **类型**: class TurnBasedLogic : IGameModeLogic
            
        - **职责**: M1模式的规则处理器。
            
        - **详细功能说明**: 这是M1模式的大脑。它告诉CommandProcessor哪些指令是合法的，以及在每个tick（虽然在回合制中tick的意义不大，但可以用于计时等）需要做什么。
            
        - **关键方法实现 (IGameModeLogic接口)**:
            
            - **Initialize(GameState state, GameSetupData setupData)**:
                
                1. 设置 state.currentTurn = PlayerTeam.Red; (红方先行)。
                    
                2. 遍历setupData中的棋子布局，初始化state.pieces字典。
                    
                3. 为每个棋子设置初始状态 status = PieceStatus.Idle | PieceStatus.IsAttackable | PieceStatus.IsObstacle;。
                    
            - **ValidateCommand(ICommand command, GameState state)**:
                
                1. **通用检查**: 检查发起指令的玩家是否就是state.currentTurn的当前回合方。如果不是，直接返回false。
                    
                2. **指令类型分派**:
					a. 获取要移动的棋子pieceData = state.pieces[moveCmd.pieceId]。  
					b. 调用GetValidMovesForPiece(pieceData, state)获取该棋子在当前局面下所有合法的落点。  
					c. 检查moveCmd.targetPosition是否在该合法落点列表内。  
					d. “王见王”的移动是合法的，相当于主动被将军，对方吃掉才算赢。  
                        
            - **OnTick(GameState state, float deltaTime)**:
                
                - 此方法在回合制中可以留空，或者用于处理回合倒计时等逻辑。
                    
        - **私有辅助方法**:
            
            - **private List<Vector2Int> GetValidMovesForPiece(PieceData piece, GameState state)**:
                
                1. 根据piece.type调用PieceMovementGenerator获取理论路径。
                    
                2. 遍历理论路径，根据state中的棋子布局进行筛选：
                    
                    - **通用阻挡**: 路径上不能有其他棋子（除非是“炮”的跳吃）。
                        
                    - **落点**:
                        
                        - 如果落点为空，合法。
                            
                        - 如果落点有**敌方**棋子，合法（吃子）。
                            
                        - 如果落点有**己方**棋子，非法。
                            
                3. 返回所有合法落点的列表。
                    
- **指令 (ICommand) 对 GameState 的修改 (Execute方法)**:
    
    - **MoveCommand.Execute(GameState state)**:
        
        1. 获取目标位置targetPos = this.targetPosition。
            
        2. 检查targetPos上是否有棋子targetPiece。
            
        3. **如果存在targetPiece (吃子)**:
            
            - 将其状态设置为targetPiece.status = PieceStatus.Dead;。
                
        4. **移动发起棋子**:
            
            - 获取movingPiece = state.pieces[this.pieceId]。
                
            - 更新其位置movingPiece.position = targetPos。
                
        5. **切换回合**:
            
            - state.currentTurn = (state.currentTurn == PlayerTeam.Red) ? PlayerTeam.Black : PlayerTeam.Red;
                
        6. **检查游戏结束**: 调用CheckGameOver(state)。
            
- **胜利条件判断**:
    
    1. **CheckGameOver(GameState state)**
        
        - **职责**: 在每次状态变更后检查游戏是否结束。
            
        - **逻辑**:
            
            1. 在state.pieces中查找双方的“将/帅”。
                
            2. 如果某一方的“将/帅”的status为Dead，则游戏结束。
                
            3. 设置state.phase = GamePhase.GameOver;和state.winner。
                
            4. (可选，但推荐) **困毙(Stalemate)判断**: 检查轮到行动的一方，是否其所有棋子都没有任何合法的移动位置。如果是，则判为和棋或负（根据具体规则）。
                

#### **2.3. Unity工作流 (Unity Workflow)**

1. **游戏模式选择**:
    
    - 在主菜单或房间设置中，当玩家选择“传统回合制”模式时，GameSetupData中会记录GameModeType.Traditional_TB。
        
2. **游戏启动**:
    
    - GameLoopController启动时，读取GameSetupData。
        
    - 调用GameModeManager.CreateLogic(GameModeType.Traditional_TB)，得到一个TurnBasedLogic的实例。
        
    - 将此实例设置给CommandProcessor。
        
3. **玩法表现**:
    
    - 当InputController检测到玩家选择了棋子，它会**请求**当前的IGameModeLogic（即TurnBasedLogic）来计算合法落点（通过一个新的接口方法，或者InputController自己组装AvailableMoveCalculator）。
        
    - View层根据返回的落点列表，显示“小绿点”。
        
    - **将军提示**: View层可以在每次GameState更新后，自行检查“将军”状态（即一方的“将”是否在对方棋子的下回合攻击范围内），如果成立，则给“将”一个特殊的警告特效。但这不影响游戏逻辑。