### **详细设计文档: B-2.1 - 实时模式核心规则 (M2)**

**文档版本**: 1.0  
**设计目标**: 实现实时公平竞技模式(M2)的所有核心游戏规则。这套规则是游戏最具创新的部分，构成了动态博弈的基础，并为后续的技能模式(M3)提供框架。

---

### **第一部分：核心功能与逻辑说明 (Functional & Logic Specification)**

在阅读技术设计前，必须理解以下四条核心实时交互逻辑：

1. **核心概念：状态与时间 (PieceStatus & Time-Driven State Machine)**
    
    - 棋子的所有行为（能否移动、攻击、被攻击、阻挡）都由其多维状态PieceStatus决定。这是一个可组合的标志枚举。
        
    - 棋子的状态会随时间自动演变。例如，一个“马”在接到移动指令后，其状态会经历Idle -> Flying (无攻击性) -> Flying | IsAttacking (有攻击性) -> Idle的生命周期。这个过程由一个内置的状态机，在每个固定的逻辑tick中进行更新。
    - 需要设计非常明确的视觉提示，例如棋子在进入攻击阶段时，模型会发红光、或出现明显的攻击特效。
        
2. **碰撞与结算 (Reactive Collision Resolution)**
    
    - 游戏不预测碰撞，而是在碰撞**实际发生时**（由Unity物理引擎检测触发），根据碰撞双方在**碰撞瞬间**的PieceStatus进行裁决。
        
    - 裁决逻辑是响应式的：如果A棋子拥有IsAttacking状态，且B棋子拥有IsAttackable状态，则B死亡。此逻辑双向检查，可能导致同归于尽。己方单位碰撞则保留高价值棋子。
    - **重点更新**：为了尽量不误伤友军，只要棋子还在移动中，就不攻击友军。只有双方都静止状态，叠加在同一个坐标格了，才判断互杀的逻辑，例如每秒10次检查有没有重叠的静止棋子。这个内容还没有体现在代码设计中，需要在开发的时候重新考虑怎么做。
        
    - 裁决结果会生成一个内部指令（如销毁棋子），以标准方式更新GameState。
        
3. **“炮”的特殊逻辑 (Targeted Strike vs. Path Collision)**
    
    - “炮”的攻击是一种**目标点打击**。其合法的攻击落点是在玩家**选择时**，根据当时是否存在“炮架”而计算出来的。
        
    - 一旦玩家向合法落点下达指令，“炮”的飞行攻击即被视为有效，即使中途“炮架”消失。
        
    - 这与“车”等棋子不同，“车”的攻击是在整个移动路径上都有效的**路径碰撞**。
        
4. **将帅激光 (Logical Projectile)**
    
    - 将帅激光是一个逻辑驱动的“弹道物体”，在GameState中有自己的数据表示（位置、方向、速度）。
        
    - 它在每个逻辑tick中更新位置，并与所有棋子进行逻辑层面的碰撞检测。
        
    - 任何棋子（无论敌我）都可以阻挡激光，使其消失。只有当它直接命中对方将帅时，才会造成击杀。
        

---

### **第二部分：技术架构与代码设计 (Technical & Code Design)**

### **模块 1: Gameplay.Rules - 公共游戏规则 (扩展)**

#### **1.1. 模块目标 (Goal)**

提供专用于实时模式的、动态的合法移动计算器。

#### **1.2. 模块内容与技术方案**

- **代码路径**: Assets/Script/_Gameplay/Rules/
    
- **类设计**:
    
    1. **RealTimeMoveCalculator**
        
        - **类型**: class
            
        - **职责**: 为一个被选中的棋子，根据当前实时的GameState，计算出所有合法的目标落点。
            
        - **详细功能说明**: InputController在玩家选择棋子后创建此类的实例，并在每一帧调用其计算方法来动态更新可移动的“绿点”。
            
        - **关键成员**:
            
            - private readonly GameState currentState;: 构造时传入的GameState引用。
                
            - private readonly int pieceId;: 要计算的棋子ID。
                
        - **关键方法**:
            
            - public List<Vector2Int> GetAvailableMovePoints(): **核心方法**。
                
                1. 获取棋子数据pieceData。
                    
                2. 调用PieceMovementGenerator获取其理论路径。
                    
                3. **遍历每条理论路径上的每个点**，检查路径上的阻挡。关键：只考虑status包含IsObstacle和Idle的棋子作为阻挡物。飞行中(Flying)或移动中(Moving)的棋子不视为固定障碍。
                    
                4. **“炮”的特殊逻辑**: 实现基于当前GameState的炮架判断逻辑。
                    
                5. 返回所有筛选出的合法落点列表。
                    

---

### **模块 2: Gameplay.RealTime - 实时模式逻辑实现**

#### **2.1. 模块目标 (Goal)**

实现IGameModeLogic接口，封装所有M2模式的规则，包括行动点、时间驱动的状态变更、碰撞裁决逻辑和胜利条件。

#### **2.2. 模块内容与技术方案**

- **代码路径**: Assets/Script/_Gameplay/RealTime/
    
- **类设计**:
    
    1. **RealTimeLogic**
        
        - **类型**: class RealTimeLogic : IGameModeLogic
            
        - **职责**: M2模式的规则处理器。
            
        - **关键方法实现 (IGameModeLogic接口)**:
            
            - **Initialize(GameState state, GameSetupData setupData)**:
                
                1. 初始化state.pieces。
                    
                2. 设置双方初始行动点state.actionPoints = { 4.0f, 4.0f };。
                    
                3. 初始化所有棋子的status = PieceStatus.Idle | PieceStatus.IsAttackable | PieceStatus.IsObstacle;。
                    
            - **ValidateCommand(ICommand command, GameState state)**:
                
                - if (command is MoveCommand moveCmd):  
                    a. 检查发起方行动点是否 >= 1.0。  
                    b. 获取棋子pieceData，检查其status是否包含Idle（即是否可以接受新指令）。  
                    c. (可选优化) 调用RealTimeMoveCalculator粗略检查目标点是否在合理范围内。
                    
                - if (command is FireLaserCommand laserCmd):  
                    a. 检查发起方行动点是否足够（激光可能消耗更多行动点）。
                    
            - **OnTick(GameState state, float deltaTime)**: **实时模式的心跳**。
                
                1. **行动点恢复**: 双方actionPoints随deltaTime增加，但不超过上限。
                    
                2. **状态机更新**: 遍历state.pieces，调用PieceStatusController.UpdatePieceStatus(piece, deltaTime)。
                    
                3. **弹道更新**: 更新所有逻辑弹道（如将帅激光）的位置，并进行碰撞检测。如果命中，生成内部指令（如Internal_DestroyPieceCommand）并立即处理。
                    
    2. **PieceStatusController**
        
        - **类型**: static class
            
        - **职责**: 管理棋子状态随时间的演变。
            
        - **详细功能说明**: 这是一个无状态的工具类，接收一个棋子数据，根据其类型和内置的计时器（需要添加到PieceData中），更新其PieceStatus。
            
        - **数据结构依赖**: 需要在PieceData中添加 float stateTimer; 字段，用于追踪当前状态已持续的时间。
            
        - **关键方法**:
            
            - public static void UpdatePieceStatus(PieceData piece, float deltaTime):
                
                1. piece.stateTimer += deltaTime;
                    
                2. switch(piece.type):
                    
                    - case PieceType.Horse: 如果 piece.status 包含 Flying，检查 stateTimer 是否达到总移动时间的80%，如果是，则给status添加IsAttacking标志。
                        
                    - ... 其他棋子类型的时间驱动状态逻辑。
                        
            - public static void OnCommandReceived(PieceData piece, ICommand command): 当棋子接收到新指令时调用，用于重置其状态和计时器。例如，收到MoveCommand后，设置status为Moving/Flying，并将stateTimer重置为0。
                
    3. **CollisionResolutionSystem**
        
        - **类型**: static class
            
        - **职责**: 接收物理碰撞事件，根据规则进行裁决。
            
        - **关键方法**:
            
            - public static ICommand ResolveCollision(PieceData pieceA, PieceData pieceB):
                
                1. 实现文档第一部分描述的裁决逻辑。
                    
                2. 根据裁决结果，返回一个或多个Internal_DestroyPieceCommand指令，或者返回null（无事发生）。
                    
    4. **Internal_DestroyPieceCommand**
        
        - **类型**: class Internal_DestroyPieceCommand : ICommand
            
        - **职责**: 一个内部使用的指令，用于将棋子标记为死亡。它绕过常规的验证流程，由系统（如碰撞或弹道系统）直接生成并执行。
            
        - **Execute(GameState state)**: state.pieces[pieceId].status = PieceStatus.Dead;。
            

#### **2.3. Unity工作流 (Unity Workflow)**

1. **物理设置**:
    
    - 为棋子Prefab添加Rigidbody和Collider（如SphereCollider）。Rigidbody应设置为Kinematic，因为我们将通过代码控制其移动，而非物理模拟。
        
    - 在Rigidbody上开启Collision Detection为Continuous Speculative，以更好地捕捉快速移动的碰撞。
        
    - 创建一个PieceCollisionDetector MonoBehaviour脚本挂在棋子Prefab上，实现OnCollisionEnter方法。当碰撞发生时，它获取碰撞双方的pieceId，然后调用CollisionResolutionSystem。
        
2. **开发流程**:
    
    - GameLoopController在每个**固定时间步长**(FixedUpdate)中，调用权威的IGameModeLogic.OnTick方法，驱动整个游戏世界的逻辑演进。
        
    - PieceView的平滑移动（插值）仍然在Update中进行。  
        .
        
    - 当PieceCollisionDetector.OnCollisionEnter被触发时，它**不直接做任何事**，而是生成一个CollisionEvent并发送给CommandProcessor，或者通过网络服务发送一个CollisionCommand给服务器。服务器上的CollisionResolutionSystem进行权威裁决，然后更新GameState，再同步给所有客户端。这确保了碰撞结果的一致性。
        

---