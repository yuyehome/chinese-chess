
- **功能列表：**
    - [ ] 基础棋盘与棋子。
    - [ ] 核心行动点系统（恢复、上限、消耗）。
    - [ ] **最简化的**网络同步，实现P2P联机对战。房主权威数据接收和下发指令，另一端播放。
    - [ ] 实现`静止`和`移动`状态，以及基于此的**常规吃子**和**闪避**。

---

 - 资源
	 - 美术
		 - 3D棋盘
		 - 3D棋子

	 - 音效
		 - 吃子
		 - 将军
		 - 将死
		 - 胜利/失败

 - 开发内容
	 - 主菜单界面
		 - 创建房间（IP和端口）
		 - 加入房间（同一台电脑，开两个端口，对战）
		 - AI陪练
	 - 游戏开始
		 - 行动点的进度条。
		 - 棋子状态
			 - 是否死亡
			 - 是否静止（待命）、移动中
			 - 是否攻击中（1，0）（攻击中碰到敌人可被攻击的子
			 - 是否实体/虚无（1，0）（是否阻挡视野）（移动是否可被穿透）
			 - 是否可被攻击
		 - 玩家操作
			 - 行动点小于1时，所有棋子不可选
			 - 行动点不小于1时，静止待命的棋子，有圈表示可选
			 - 选择待命棋子时，罗列显示所有可移动的落点，高亮显示
				 - 点击落点后，发送操作请求给房主
				 - 点击切换其它棋子时，取消原来棋子的高亮，刷新新棋子的落点高亮
		 - 棋盘
			 - 棋盘格子数据标记
			 - 落点数据标记
			 
		 - 棋子可行动的落点
			 - 公共逻辑
				 - 友军冲突。如果某个棋子从A点移动到B点，在移动的过程中，B点在自己的其它棋子不能作为落点。
				 - 可移动范围内，所有无阻碍的点，或者第一个有阻碍的敌方。阻碍就按棋子的”实体“状态来判断。
			 - 车。直线范围移动，或攻击第一个阻碍。整个移动过程都是在攻击
			 - 马。移动/攻击”日“字的对角，有别腿马的判断。跳跃过程为虚体。
			 - 象/相。移动/攻击”田“字的对角，有象眼的判断，不能过河。跳跃过程为虚体。
			 - 仕/士。移动/攻击”口“字的对角，即相邻的斜边，九宫格内。
			 - 将/帅。移动/攻击相邻的直边，九宫格内。
			 - 炮/砲。直线移动，与车相同，移动过程为实体。隔一个子攻击，跳跃过程为虚体。
			 - 兵/卒。相邻的直边。过河之前只能向前走，过河之后可以向前或者横向。
			 
		 - 房主逻辑
			 - 接受网络指令
			 - 逻辑判断指令是否合法，及对应的指令结果
				 - 棋子移动
				 - 扣行动点
				 - 棋子死亡消失
				 - 将军提示
				 - 将帅死亡游戏结局
				 - 游戏计时
				 - 某一方无棋子可过河时，2分钟倒计时，平局
				 - 双方都无棋子过河时，1分钟倒计时，平局
				 - 总游戏超过30分钟，平局
			 - 下发播放指令
				 

---
### **开发蓝图：从单机逻辑到联机对战**

我们将分三个主要阶段完成Demo的核心功能：

#### **阶段 1: 完善单机游戏逻辑 (我们当前所处阶段)**

- **目标:** 实现一个功能完整的、可以在一台电脑上玩的中国象棋游戏（暂时忽略实时和行动点）。
    
- **任务 1.1: 完整实现RuleEngine**
    
    - 为马、象、士、将、炮、兵添加移动规则生成逻辑。
        
- **任务 1.2: 实现棋子移动**
    
    - 当玩家点击一个合法的高亮落点时，棋子在数据层(BoardState)和视觉层(场景中的GameObject)上都移动到新位置。
        
- **任务 1.3: 实现吃子逻辑**
    
    - 当棋子移动到一个有敌方棋子的位置时，敌方棋子被移除。
        
- **任务 1.4: 完善游戏流程**
    
    - 实现简单的轮流走棋（红方走完，黑方走）。
        
    - 实现将军和将死的判断。
        

#### **阶段 2: 引入实时行动点系统**

- **目标:** 打破回合制，引入GDD中的核心机制。
    
- **任务 2.1: 实现行动点系统**
    
    - 创建EnergySystem，随时间恢复行动点。
        
    - 玩家移动棋子时消耗行动点。
        
    - UI上显示行动点进度条。
        
- **任务 2.2: 移除轮流走棋限制**
    
    - 允许双方玩家在有行动点的情况下随时操作自己的棋子。
        

#### **阶段 3: 集成Fish-Net网络**

- **目标:** 将单机游戏改造成你设计的“房主权威”网络对战模式。
    
- **任务 3.1: 搭建网络基础**
    
    - 创建NetworkManager，设置简单的UI来“创建房间”（作为房主/Host）和“加入房间”（作为客户端/Client）。
        
    - 将棋子Prefab网络化，添加NetworkObject组件。
        
- **任务 3.2: 同步游戏状态**
    
    - 将BoardState的权威实例放在房主端。
        
    - 使用[ServerRpc]将客户端的操作请求（如“我想把(x1,y1)的棋子移动到(x2,y2)”）发送给房主。
        
    - 房主验证操作合法性后，更新权威BoardState。
        
    - 使用SyncVar或[ObserversRpc]将BoardState的变化同步给所有客户端。
        
- **任务 3.3: 客户端播放**
    
    - 客户端的BoardRenderer不再直接响应本地操作，而是监听来自服务器的状态更新，并据此渲染棋盘。