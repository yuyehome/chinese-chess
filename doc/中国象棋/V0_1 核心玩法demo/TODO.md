### **开发路线图规划**

我们的目标是按照功能的重要性和依赖关系，循序渐-进地构建游戏。

- **阶段一：实现核心博弈机制 - “将帅激光”** (已完成重构，此为新功能)
    
    - **目的：** 补全设计文档中的核心胜利条件，增加游戏的独特性和终局的紧张感。
        
- **阶段二：构建可玩的游戏循环 - “基础AI对手”**
    
    - **目的：** 让游戏具备单人可玩性，为后续的玩法测试、平衡性调整提供一个可靠的“陪练”。
        
- **阶段三：深化核心玩法 - “技能系统框架与原型”**
    
    - **目的：** 搭建游戏最核心的、最具扩展性的技能系统框架，并实现几个代表性技能来验证其可行性。
        

---

### **阶段一：实现核心博弈机制 - “将帅激光”**

#### **🎯 目标:**

在满足“王见王”条件时，允许玩家操作 将/帅 发射激光攻击对方主帅，替代当前代码中的“飞将”逻辑。

#### **💻 开发任务:**

1. **规则与输入逻辑修改:**
    
    - 修改 RuleEngine 或 RealTimeModeController，当检测到“王见王”时，不再将对方将/帅的位置作为一个普通的移动点，而是标记为一个特殊的“攻击目标”。
        
2. **视觉表现:**
    
    - 在 BoardRenderer 中，为这个特殊的“攻击目标”创建一个独特的视觉标记（例如，一个红色的准星图标），以区别于普通移动标记。
        
    - 创建一个“激光”的预制件（Prefab），可以是一个简单的拉伸圆柱体或带粒子效果的对象。
        
3. **激光行为实现:**
    
    - 当玩家点击特殊攻击标记时，在 RealTimeModeController 中触发一个新的 FireLaser 方法。
        
    - 此方法会：
        
        - 消耗1点行动点。
            
        - 在 BoardRenderer 中实例化激光预制件。
            
        - 驱动激光匀速飞向目标。
            
    - 为激光预制件添加一个 LaserComponent.cs 脚本，负责处理自身的移动和碰撞检测。
        
4. **碰撞与摧毁逻辑:**
    
    - LaserComponent 在飞行中，如果与其他棋子（不包括发射者）发生碰撞：
        
        - 它会摧毁路径上的第一个棋子（无论敌我）。
            
        - 激光自身也被摧毁。
            
        - 如果命中的是对方将/帅，则游戏结束。
            

#### **🤔 待确认的逻辑细节:**

1. **激光对棋子的伤害规则：** GDD中提到“挡路棋子被摧毁”，这是否意味着任何棋子（包括我方棋子）如果不慎挡在激光路径上，都会被摧毁？还是说激光只会摧毁**敌方**的挡路棋子？
    
    - **选项A (无差别伤害):** 摧毁路径上的**任何**第一个棋子。这会增加策略深度，玩家需要“清场”或小心操作，避免误伤。
        
    - **选项B (仅敌方伤害):** 只摧毁路径上的第一个**敌方**棋子，我方棋子可以安全阻挡。这更符合直觉，对玩家更友好。
        
    - **我倾向于选项A**，因为它带来了更高的风险和博弈性，但请您确认。
        
2. **激光的速度：** GDD中提到“速度较慢（如5格/秒）”。这个速度是否合适？我们可以先按这个值实现，后续再根据手感调整。
    

---

### **阶段二：构建可玩的游戏循环 - “基础AI对手”**

#### **🎯 目标:**

创建一个可以与玩家进行实时对战的简单AI，使游戏可以独立运行并完成一局完整的对战。

#### **💻 开发任务:**

1. **AI控制器框架:**
    
    - 创建一个 AIController.cs 类。
        
    - 在 GameManager 中添加逻辑，可以在游戏开始时根据模式（例如，PVE模式）来决定是启用 PlayerInput 还是 AIController。
        
2. **基础决策逻辑 (笨拙AI):**
    
    - AIController 内设置一个计时器（例如，每1-2秒进行一次决策）。
        
    - 当计时器触发且AI拥有足够行动点时：
        
        1. 从AI所有可动的棋子中，**随机**选择一个。
            
        2. 从该棋子的所有合法移动中，**随机**选择一个目标点。
            
        3. 执行移动。
            
3. **决策逻辑优化 (简单AI):**
    
    - 在“笨拙AI”的基础上增加简单的启发式规则：
        
        - **进攻倾向：** 如果有可以“吃掉”对方棋子的走法，优先选择。
            
        - **价值判断：** 如果有多个可“吃子”的选择，优先吃掉PieceValue最高的敌方棋子。
            
        - **随机性保留：** 在没有吃子机会时，仍然随机移动，以避免AI行为过于死板。
            

#### **🤔 待确认的逻辑细节:**

1. **AI的反应速度：** AI的决策频率是固定的（例如，每秒一次），还是在一个随机范围内（例如，0.8秒到1.5秒之间）？后者能更好地模拟人类不同的反应时间。
    
    - **我建议使用随机范围**，让AI的行为更自然。
        
2. **AI的能量管理：**
    
    - **选项A (即时花费):** 只要有1点能量就立即寻找可行的操作并执行。这会让AI看起来很“忙”。
        
    - **选项B (积攒能量):** AI会倾向于将能量攒到3-4点，然后快速连续行动，模拟“爆发”。
        
    - 对于基础AI，**我建议先实现选项A**，因为它最简单。我们可以在后续版本中再为AI增加更复杂的资源管理策略。
        
3. **AI的目标范围：** 当前阶段的AI，其目标是**能玩、能测试**即可。我们暂时不引入复杂的局面评估函数、Minimax算法等，这些可以作为后续“困难AI”的开发内容。我们是否对此达成共識？
    

---

### **阶段三：深化核心玩法 - “技能系统框架与原型”**

#### **🎯 目标:**

设计并实现一个灵活、可扩展的技能系统框架，并制作2-3个效果各异的技能作为原型，为未来大量的“武将卡”技能开发铺路。

#### **💻 开发任务:**

1. **架构设计 (数据驱动):**
    
    - 创建 SkillData.cs，使用 ScriptableObject 来定义一个技能。它将包含技能名称、描述、消耗、冷却时间、效果类型等纯数据。这允许策划在不改代码的情况下创建和调整技能。
        
    - 创建抽象基类 SkillEffect.cs，定义所有技能效果的通用接口，如 Activate(), Deactivate(), Tick()。
        
    - 创建具体的技能效果类，如 ShieldSkillEffect.cs, StunSkillEffect.cs 等，继承自 SkillEffect。
        
2. **技能管理器:**
    
    - 修改 PieceComponent，使其可以持有一个或多个技能的引用。
        
    - 创建一个 SkillManager.cs，负责处理技能的触发、能量/冷却结算和效果应用。
        
3. **原型技能实现:**
    
    - **技能1: 坚守 (被动/主动):** 激活后，棋子在一段时间内变为无敌状态（IsVulnerable = false）。
        
    - **技能2: 冲撞 (主动):** 车或马的专属技能。移动时，对路径上碰撞到的第一个敌方单位造成“击退”或“眩晕”效果。
        
    - **技能3: 伪装 (主动):** 兵的专属技能。激活后，在一段时间内，在敌人视角里，该兵看起来像一个车。（这个比较有趣，可以验证我们的欺诈类技能框架）
        
4. **UI集成:**
    
    - 当选中一个带主动技能的棋子时，在屏幕上显示一个技能按钮。
        
    - 按钮上需要能显示冷却状态。
        

#### **🤔 待确认的逻辑细节:**

1. **技能的激活方式与消耗：**
    
    - 技能是否统一消耗“行动点”？还是有独立的“法力值”或“冷却时间”系统？
        
    - **我建议初期简化设计：** 主动技能消耗1点行动点，并附带一个独立的冷却时间（例如5秒）。这样可以复用现有系统，避免过早引入新资源。
        
2. **状态冲突处理：** 如果一个棋子同时中了“眩晕”（不能动）和“加速”（移速加快）两个效果，该如何处理？我们需要定义一个清晰的**状态优先级**或**互斥规则**。
    
    - **初步建议：** 负面硬控状态（如眩晕、禁锢）的优先级最高，会覆盖其他所有移动类状态。
        
3. **原型技能效果定义：**
    
    - **坚守：** 持续时间是多久？比如3秒？冷却时间多久？比如10秒？
        
    - **冲撞-眩晕：** “眩晕”状态的具体效果是什么？我们目前没有“无法移动”的逻辑，需要实现。一个简单的实现是：在RealTimeModeController中，当尝试选择或移动棋子时，检查其是否处于“眩晕”状态，如果是则操作失败。眩晕持续多久？比如1.5秒？
        
    - **伪装：** 这个技能的实现会稍微复杂，需要修改BoardRenderer的逻辑，使其能根据棋子的某个状态来渲染一个不同的模型/贴图给对方玩家看。这是一个很好的技术验证。