请一定要注意，这是个实时对战游戏。请放弃任何回合制中的思路。例如你说移动完成时【重置所有棋子的状态为默认值】。这个不对吧？要注意，每个棋子都是独立的，不会因为某一个棋子移动完成了矶把其它的棋子的状态修改掉，其它的棋子可能正在移动的过程中呢。

我再梳理一下棋子的状态（每个棋子完全独立的）【不管你的代码怎么实现，我必须要能在任何时候确定某一个具体棋子的以下几个状态值是什么】：  
是否死亡（暂时无用，但是记录着，用于未来增加的技能判定。例如招魂术可以随机复活某个棋子。注意棋子只有死活，没有血条，不存在中间状态。在规则内受到攻击就是死亡。所以也不存在攻击力，防御力，伤害公式等。）  
是否移动中（静止待命的棋子才能被选择进行操作，已经在移动过程中就不可操作了）  
是否实体/虚无（虚无可以理解为无敌状态，例如炮马象飞在空中高处的时候，或者未来隐身术等）（目前所有棋子都是实体，代码保留写死）  
是否可被攻击（并不是有实体就能被攻击例如石化术，这个棋子是实体，阻挡视野，能被架炮，但是不能被攻击）  
是否正在攻击状态（自己的碰撞范围对敌人造成攻击）

吃子的逻辑，只要自己是处理攻击状态，并且在自己的碰撞检测范围之内 有 敌方的可被攻击状态 的棋子，那么敌方棋子就死掉了。如果双方都在攻击状态 并且双方都在可被攻击状态，那么碰撞后就一起死掉。要注意，这两个状态是分离的。

所有棋子的可移动规则与之前的传统象棋是相同的，移动的路线等也是相同的。但是，是否可被攻击，是否正在攻击，这些是有区别，需要注意的。

所有棋子在静止状态中，都是可被攻击的，并且都“不”处于状态。区别只在移动的过程中。

车兵卒将帅仕士都是一样的逻辑，只要在移动中，就保持攻击状态，并且也一直处于可被攻击的状态。（未来增加武将卡，是根据不同棋子类型的，所以车兵卒将帅仕士也可以考虑拆分成不同的代码）

炮在（不隔子）平移的过程中，不处于攻击状态，并且也一直处于可被攻击的状态。  
炮在（隔子跳跃）攻击的过程中，在这个移动过程的0.9~1.0这个后半段才处于攻击状态（可以理解为向下砸的时候才有伤害），并且也一直处于可被攻击的状态。  

马和象，在这个移动过程的0.6~1.0这个后半段才处于攻击状态（与炮类似），但中间的0.2~0.8处于不可被攻击的状态（可以理解为在空中闪避）。如果两个马在同一时间开始对吃，实际上两个都没死，因为在空中相遇的时候差不多是0.5处于不可被攻击的状态，并也都没有攻击性。但是如果A马比B马操作的慢，操作的迟，那么相当于B从上向下压A马，A死亡。

如果还有哪些不理解的请你一定要问我，不要自作主张。不要使用配置化的方式，可以考虑使用策略模式之类的代码实现。

另外，代码改动时，需要注意是否会影响到原来的传统回合制象棋。如果有影响就把之前传统回合制单独写一份，那个回合制的不重要。以及要考虑一下是否会影响到架炮和可选落点的逻辑。

另外，是否一定要增加Rigidbody？不增加行不行？

不要轻易的去掉之前的高亮逻辑。

吃子的逻辑要注意什么时候清除掉死子。

这次的改动太大，几乎肯定会影响到原来的传统回合制象棋，有没有办法完全做到代码隔离？

特别注意，我这次的要求很多，太过复杂，请你不要一次性做完，你再梳理一次，分阶段完成，请你先把你的理解和计划再说一下，列出来。我确定没问题就告诉你做哪一条或者哪几条。



========================准备开始第二阶段


### **我的理解与分阶段开发计划 (待您确认)**

基于您最新的、详细的需求，我已经重新梳理了我的理解，并制定了一个清晰、分步的开发计划。请您审阅，确认无误后，我们再开始具体实施。

#### **第一阶段：数据结构与状态机基础**

**目标:** 搭建能够承载您所有复杂状态的数据结构，并建立一个管理这些状态的核心机制。这是所有后续玩法的基础。

- **1.1 - 创建 PieceFacade 和 RealTimePieceState:**
    
    - **理解:** 我们需要一个统一的入口来访问一个棋子的所有信息（视觉对象GameObject, 逻辑数据Piece, 实时状态等）。PieceFacade（外观模式）就是这个入口。RealTimePieceState 则是一个纯数据类，用于存储您定义的是否死亡、是否移动中等所有状态。
        
    - **计划:**
        
        - 创建 RealTimePieceState.cs 类，包含您定义的5个状态变量 ( isDead, isMoving, movementType, isVulnerable, isAttacking )。
            
        - 创建 PieceFacade.cs 类。这个类将挂载在每个棋子的Prefab上，取代现在的 PieceComponent。它会包含对 GameObject、Piece 数据、RealTimePieceState 实例的引用。
            
        - RealTimeModeController 将持有一个 Dictionary<Vector2Int, PieceFacade> 来快速通过坐标查找棋子。
            
- **1.2 - 建立状态更新循环:**
    
    - **理解:** 棋子的状态（尤其是移动过程中的状态）是随时间变化的。我们需要一个地方来集中处理这些更新。
        
    - **计划:**
        
        - 在 RealTimeModeController 中创建一个 UpdateAllPieceStates() 方法，并在 Update() 中每帧调用。
            
        - 这个方法会遍历所有正在移动的棋子。
            
        - 根据每个棋子的移动进度 (moveProgress) 和其类型 (车 vs 马)，**完全按照您定义的规则**来更新它的 RealTimePieceState。
            
            - **伪代码示例:**
                
                codeCode
                

#### **第二阶段：战斗逻辑与碰撞检测**

**目标:** 实现核心的吃子和碰撞双亡逻辑。

- **2.1 - 创建 CombatManager:**
    
    - **理解:** 战斗判定逻辑比较复杂，最好独立成一个模块，而不是全塞在 RealTimeModeController 里。
        
    - **计划:**
        
        - 创建一个 CombatManager.cs 类。
            
        - RealTimeModeController 在 Update() 的最后，会调用 combatManager.ProcessCombat()。
            
- **2.2 - 实现碰撞检测与伤害判定:**
    
    - **理解:** 我们需要每帧检测所有处于“攻击状态”的棋子，看它们的攻击范围是否覆盖了处于“可被攻击状态”的敌方棋子。
        
    - **计划:**
        
        - 在 CombatManager.ProcessCombat() 中:
            
            - 获取所有棋子的列表。
                
            - 使用两层循环 for each pieceA in allPieces 和 for each pieceB in allPieces 来进行配对检查（A和B不能是同一方）。
                
            - **伪代码示例:**
                
                codeCode
                
        - IsInAttackRange() 是一个辅助函数，它会检查两个棋子的 GameObject 之间的距离是否小于一个阈值（比如棋子半径）。
            
        - Kill(piece) 函数会负责处理棋子死亡的所有逻辑：更新BoardState、销毁GameObject、更新RealTimeModeController中的棋子列表。
            

#### **第三阶段：规则整合与表现**

**目标:** 将新的状态和战斗系统与现有的移动规则、高亮显示等功能无缝结合。

- **3.1 - 整合移动选择逻辑:**
    
    - **理解:** 现在只有静止的棋子才能被操作。
        
    - **计划:**
        
        - 修改 RealTimeModeController.OnPieceClicked()。在最开始就检查：if (clickedPieceFacade.realTimeState.isMoving) return;。
            
- **3.2 - 整合移动规则 (RuleEngine):**
    
    - **理解:** RuleEngine.GetValidMoves 在计算炮的落点时，需要知道中间是否有“炮架”。现在“炮架”的定义是任何“实体”棋子，而一个棋子是否实体，取决于它的 RealTimePieceState。这会造成RuleEngine（纯静态工具类）和RealTimePieceState（运行时数据）的耦合。
        
    - **解决方案:**
        
        - 我们将**克隆一份** RuleEngine.cs 为 RealTimeRuleEngine.cs。
            
        - 修改 RealTimeRuleEngine 的方法，让它们可以接收一个棋子列表（包含实时状态）作为额外参数，或者直接接收 RealTimeModeController 的引用来查询状态。这样，当它判断炮的路径时，就能查询路径上的棋子**当前是否为实体**。
            
        - RealTimeModeController 将调用 RealTimeRuleEngine，而TurnBasedModeController继续调用旧的RuleEngine，完美隔离。
            
- **3.3 - 视觉表现增强:**
    
    - **理解:** 我们需要视觉上区分不同状态的棋子。
        
    - **计划:**
        
        - 在 BoardRenderer 中增加新方法：
            
            - SetEtherealEffect(pieceGameObject, bool active): 切换半透明/虚化着色器。
                
            - ShowAttackEffect(pieceGameObject, bool active): 播放攻击光效。
                
        - 在 RealTimeModeController.UpdateAllPieceStates() 中，当棋子状态发生变化时，调用BoardRenderer的这些新方法来更新视觉效果。
            
        - **高亮逻辑不受影响**，ShowValidMoves 依然有效，因为它只在高亮静止的棋子。
        - 