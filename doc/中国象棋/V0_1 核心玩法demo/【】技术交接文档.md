## 技术交接文档

这份文档旨在帮助任何新的开发者（或AI）快速理解项目的技术架构、代码职责和未来方向。

### **a. 技术架构概述**

本项目是一款基于 **Unity** 引擎开发的实时策略对战游戏。其技术架构可以分为以下几个核心层面：

1. **核心 gameplay 架构 (MVCS变种):**
    
    - **Model (数据模型):** 以 BoardState.cs 为核心，它代表了棋盘上所有**静止**棋子的纯逻辑数据。这是一个“唯一真实来源(Single Source of Truth)”。
        
    - **View (视图):** BoardRenderer.cs 负责将 BoardState 和棋子的动态视觉表现渲染到屏幕上。它管理所有棋子GameObject的创建、销毁和动画。
        
    - **Controller (控制器):**
        
        - **GameManager.cs:** 作为顶层协调者和单例，负责初始化游戏、管理游戏主循环(Update)、并作为各模块的粘合剂。
            
        - **GameModeController (策略模式):** 使用 TurnBasedModeController 和 RealTimeModeController 两个子类来封装不同模式下的核心逻辑，实现了模式的解耦。
            
        - **IPlayerController (接口):** 定义了控制一方的通用接口，其实现包括 PlayerInputController (真人玩家), AIController (AI), 未来还可以轻松扩展为 NetworkPlayerController。
            
    - **Service (服务/系统):**
        
        - EnergySystem.cs, CombatManager.cs, RuleEngine.cs 等，这些是无状态或只管理自身状态的纯逻辑模块，为上层提供具体的功能（能量计算、战斗裁决、规则判断）。
            
2. **网络技术栈:**
    
    - **网络框架:** **FishNet**。一个高性能、低GC的Unity网络解决方案。
        
    - **匹配与后端服务:** **Steamworks.NET**。利用Steam强大的Lobby系统进行房间的创建、查找、加入和玩家信息同步。
        
    - **传输层:** **FishySteamworks**。这是一个FishNet的传输层实现，它将FishNet的底层数据包通过Steam的P2P网络进行传输，无需自建中继服务器，非常适合独立游戏。
        
    - **同步模型:**
        
        - **玩家数据:** GameNetworkManager 中的 SyncDictionary<int, PlayerNetData> 同步所有玩家的基础信息。
            
        - **棋盘状态:** GameNetworkManager 中的 SyncList<NetworkPieceData> 在游戏开始时，由服务器一次性将整个棋盘的初始布局同步给客户端。
            
        - **游戏操作:** 移动请求通过 [ServerRpc] 从客户端发送到服务器，服务器验证后执行逻辑，然后状态变化会通过SyncVar或SyncList广播回所有客户端。（当前代码主要通过状态同步，操作同步较少）。
            
3. **AI 架构 (策略模式):**
    
    - **IAIStrategy 接口:** 定义了所有AI决策逻辑的统一接口。
        
    - **具体策略实现:** EasyAIStrategy, HardAIStrategy, VeryHardAIStrategy。每个类封装了不同复杂度的决策算法。这种设计使得添加新难度或完全不同行为的AI变得非常容易。
        
4. **场景与数据流:**
    
    - MainMenu.unity: 负责UI交互、Steam登录、Lobby创建/加入。
        
    - Game.unity: 核心战斗场景。
        
    - **场景间数据传递:** 使用静态类 GameModeSelector 来传递玩家选择的游戏模式和AI难度等简单配置。
        

---

### **b. 代码文件职责清单**

#### **Core - 核心逻辑**

- _Scripts/Core/GameManager.cs
    
    - **职责:** **游戏总指挥官**。作为单例，是整个游戏场景的入口和核心。负责初始化 BoardState、BoardRenderer、EnergySystem等核心模块；根据GameModeSelector选择并初始化对应的GameModeController和Player/AIController；管理游戏主循环(Update)，驱动实时模式的逻辑Tick；处理游戏结束逻辑。在PVP模式中，区分服务器和客户端逻辑。
        
- _Scripts/Core/BoardState.cs
    
    - **职责:** **逻辑棋盘**。纯数据类，用二维数组记录所有**静止**棋子的位置和信息。提供查询、设置、移动棋子的接口。是所有规则计算的“唯一真实数据源”。
        
- _Scripts/Core/RuleEngine.cs
    
    - **职责:** **象棋规则裁判**。纯静态工具类，负责计算任何给定棋子在给定BoardState下的所有合法移动。不包含任何游戏状态或流程。
        
- _Scripts/Core/EnergySystem.cs
    
    - **职责:** **行动点管理器**。负责管理双方玩家的行动点（能量）的恢复、消耗和查询。
        
- _Scripts/Core/CombatManager.cs
    
    - **职责:** **实时战斗裁决者**。在实时模式下，负责检测棋子间的碰撞，并根据RealTimePieceState中的攻击/防御状态来决定伤害和死亡。
        
- _Scripts/Core/RealTimePieceState.cs
    
    - **职责:** **实时棋子状态机**。存储棋子在实时模式下的动态数据，如是否移动中、是否无敌、是否可攻击、移动进度等。
        
- _Scripts/Core/PieceData.cs
    
    - **职责:** **基础数据定义**。定义了 PlayerColor, PieceType, Piece, GameStatus 等核心枚举和结构体。
        
- _Scripts/Core/PieceValue.cs
    
    - **职责:** **棋子价值库**。静态类，提供不同棋子类型的内在价值，用于AI评估和友方碰撞裁决。
        
- _Scripts/Core/GameModeSelector.cs
    
    - **职责:** **场景间数据传递器**。一个简单的静态类，用于在MainMenu场景和Game场景之间传递玩家选择的游戏模式和AI难度。
        

#### **GameModes - 游戏模式**

- _Scripts/GameModes/GameModeController.cs
    
    - **职责:** **游戏模式基类**。定义了所有游戏模式控制器的抽象基类，使用了策略设计模式。
        
- _Scripts/GameModes/RealTimeModeController.cs
    
    - **职责:** **实时模式逻辑核心**。管理所有移动中棋子的状态，驱动CombatManager进行战斗检测，执行移动指令并处理动画回调。
        
- _Scripts/GameModes/TurnBasedModeController.cs
    
    - **职责:** **回合制模式逻辑核心**。管理当前回合方，处理棋子选择、移动执行和回合切换的逻辑。
        

#### **Controllers - 输入与AI**

- _Scripts/Controllers/IPlayerController.cs
    
    - **职责:** **玩家控制器接口**。定义了控制一方势力的通用接口，使得真人玩家、AI、网络玩家可以被GameManager统一管理。
        
- _Scripts/Controllers/PlayerInputController.cs
    
    - **职责:** **本地玩家输入处理器 (实时模式)**。监听鼠标点击，将玩家的输入（选择棋子、点击目标格）转化为对GameManager的移动请求。
        
- _Scripts/Controllers/TurnBasedInputController.cs
    
    - **职责:** **本地玩家输入处理器 (回合制模式)**。专门为回合制设计，直接与TurnBasedModeController交互，处理回合制下的点击逻辑。
        
- _Scripts/Controllers/AIController.cs
    
    - **职责:** **AI代理**。作为AI的MonoBehaviour载体，管理决策计时器，并在后台线程中调用IAIStrategy进行思考，然后将决策结果提交给GameManager。
        
- _Scripts/Controllers/AI/IAIStrategy.cs
    
    - **职责:** **AI策略接口**。定义了所有AI决策算法的统一接口，核心是FindBestMove方法。
        
- _Scripts/Controllers/AI/EasyAIStrategy.cs, HardAIStrategy.cs, VeryHardAIStrategy.cs
    
    - **职责:** **具体AI实现**。实现了不同难度的AI逻辑。从简单的随机/贪心算法，到包含局势评估和Minimax搜索的复杂算法。
        

#### **Network - 网络**

- _Scripts/Network/GameNetworkManager.cs
    
    - **职责:** **游戏内网络同步核心**。作为一个NetworkBehaviour，它是在游戏场景中同步状态的权威。使用SyncList和SyncDictionary来同步棋盘布局和玩家信息。提供ServerRpc供客户端注册玩家。
        
- _Scripts/Network/LobbyManager.cs
    
    - **职责:** **Steam Lobby管理器**。封装了所有与Steam Lobby相关的操作：创建、查找、加入、离开、更新Lobby数据。同时，它还负责启动FishNet的Host或Client。
        
- _Scripts/Network/SteamManager.cs
    
    - **职责:** **Steam API底层封装**。负责初始化和关闭Steamworks.NET，并提供获取本地玩家姓名、SteamID等基础信息的全局单例。
        
- _Scripts/Network/LobbyItem.cs
    
    - **职责:** **Lobby列表项UI**。挂载在Lobby列表的Prefab上，负责显示单个Lobby的信息并处理加入按钮的点击事件。
        
- _Scripts/Network/PlayerNetData.cs & NetworkPieceData.cs
    
    - **职责:** **网络数据结构体**。定义了用于在网络间传输的轻量级、可序列化的玩家和棋子数据结构。
        

#### **View & Components - 视图与组件**

- _Scripts/BoardRenderer.cs
    
    - **职责:** **棋盘视觉渲染器**。负责将BoardState中的逻辑数据“画”成场景中的3D对象。管理所有棋子GameObject的创建、销毁、移动动画、高亮等所有视觉表现。
        
- _Scripts/PieceComponent.cs
    
    - **职责:** **棋子“身份证”**。挂载在棋子Prefab上，存储该GameObject对应的逻辑数据（PieceData），逻辑坐标（BoardPosition）和实时状态（RTState）。
        
- _Scripts/MoveMarkerComponent.cs
    
    - **职责:** **移动标记“身份证”**。挂载在移动标记Prefab上，仅用于存储其代表的棋盘坐标。
        

#### **UI - 用户界面**

- _Scripts/UI/MainMenuController.cs
    
    - **职责:** **主菜单UI总管**。处理主菜单场景中几乎所有的UI交互，包括模式选择、打开/关闭各面板、获取输入框内容、调用LobbyManager执行网络操作、更新Lobby房间内的玩家信息和头像等。
        
- _Scripts/UI/GameUIManager.cs
    
    - **职责:** **游戏内UI布局管理器**。负责在游戏场景中动态创建和布局UI元素（如能量条），并能根据屏幕朝向（横/竖屏）自动调整布局。
        
- _Scripts/UI/EnergyBarSegmentsUI.cs
    
    - **职责:** **分段式能量条UI**。一个具体的UI组件，负责根据传入的能量值，动态更新分段式能量条的显示效果。
        

---

### **c. 未来优化与重构建议**

当前的代码架构非常清晰，特别是核心逻辑、控制器和视图的分离做得很好。以下是一些着眼于未来扩展性和维护性的建议：

1. **【结构】GameManager职责减负:**
    
    - **问题:** GameManager目前承担了太多的职责：场景初始化、控制器管理、游戏循环驱动、AI数据提供者等，有成为“上帝类”(God Class)的趋势。
        
    - **建议:**
        
        - 可以创建一个GameSetupManager或SceneInitializer，专门负责游戏开始时的初始化流程（创建BoardState, 注入依赖等）。
            
        - PVP相关的初始化逻辑 (HandlePVPInitialization) 可以抽离到一个PVPGameFlowManager中，让GameManager只关注通用的游戏逻辑。
            
        - AI需要的数据 (GetSimulatedPiecesOfColorFromBoard) 可以通过一个更纯粹的BoardQueryService来提供，而不是直接调用GameManager。
            
2. **【性能】战斗碰撞检测优化:**
    
    - **问题:** CombatManager中的ProcessCombat方法使用了O(n²)的双重循环来检测所有棋子间的碰撞。对于32个棋子来说完全没问题，但如果未来加入“召唤”等技能导致单位数量增多，性能会成为瓶颈。
        
    - **建议:**
        
        - **空间划分 (Spatial Partitioning):** 将棋盘划分为一个逻辑网格。在检测碰撞时，每个棋子只需要和它所在网格以及相邻网格内的其他棋子进行检测，将复杂度从O(n²)降低到接近O(n)。
            
3. **【可扩展性】技能系统的架构设计:**
    
    - **背景:** 这是未来的核心玩法，需要一个高度可扩展的架构。
        
    - **建议:**
        
        - **使用ScriptableObject定义技能:** 每个技能（隐身、召唤、反击等）都创建一个SkillData类型的ScriptableObject资产。这使得非程序员（如策划）可以方便地创建和调整技能数值，而无需修改代码。
            
        - **组件化技能逻辑:** 创建一个SkillBase的抽象类，每个具体的技能（如StealthSkill, SummonSkill）都继承自它。在游戏开始时，根据玩家的“武将卡”配置，将对应的技能脚本动态地AddComponent到PieceComponent所在的GameObject上。
            
        - **事件驱动系统 (Event Bus):** 建立一个全局的游戏事件系统（例如 GameEvents.OnPieceMove, GameEvents.OnPieceTakesDamage）。技能组件可以订阅这些事件，当事件发生时，触发自身的逻辑。例如，一个“反击”技能可以订阅OnPieceTakesDamage事件，在受到伤害时执行反击逻辑。这能极大地解耦技能与核心游戏逻辑。
            
4. **【网络】移动同步模型的演进:**
    
    - **现状:** 目前主要依赖服务器权威下的状态同步（SyncList）。棋子移动是客户端发起RPC，服务器执行逻辑，然后所有客户端观察到状态变化。
        
    - **建议 (远期):** 对于一个快节奏的RTS游戏，可以考虑引入**客户端预测(Client-Side Prediction)**和**服务端和解(Server Reconciliation)**。
        
        - **流程:** 客户端请求移动后，不等待服务器回应，**立即**在本地开始移动动画（客户端预测），这会让操作手感极度流畅。当服务器的权威状态同步回来时，如果与本地预测有偏差，再平滑地将棋子位置修正到正确位置（和解）。
            
        - **收益:** 能在有网络延迟的情况下，提供近乎零延迟的操作体验。这是专业RTS/MOBA游戏的核心技术之一。
            
5. **【代码质量】硬编码字符串和魔法数字:**
    
    - **问题:** 代码中存在一些硬编码的字符串，如Lobby的Key ("game_id")，Layer的名字 ("EtherealPieces")等。
        
    - **建议:**
        
        - 将这些常量统一放到一个或多个静态的Constants类中（如NetworkConstants, GameConstants）。这样便于统一管理和修改，并能避免因拼写错误导致的bug。